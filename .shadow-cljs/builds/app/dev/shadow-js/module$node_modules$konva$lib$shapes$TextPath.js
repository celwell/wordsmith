["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/konva/lib/shapes/TextPath.js"],"~:js","shadow$provide.module$node_modules$konva$lib$shapes$TextPath=function(global,require,module,exports){function _fillFunc(context){context.fillText(this.partialText,0,0)}function _strokeFunc(context){context.strokeText(this.partialText,0,0)}var __extends=this&&this.__extends||function(){var extendStatics=function(d$jscomp$0,b$jscomp$0){extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b}||function(d,b){for(var p in b)b.hasOwnProperty(p)&&(d[p]=b[p])};return extendStatics(d$jscomp$0,\nb$jscomp$0)};return function(d,b){function __(){this.constructor=d}extendStatics(d,b);d.prototype=null===b?Object.create(b):(__.prototype=b.prototype,new __)}}();Object.defineProperty(exports,\"__esModule\",{value:!0});var Util_1=require(\"module$node_modules$konva$lib$Util\");global=require(\"module$node_modules$konva$lib$Factory\");var Shape_1=require(\"module$node_modules$konva$lib$Shape\"),Path_1=require(\"module$node_modules$konva$lib$shapes$Path\"),Text_1=require(\"module$node_modules$konva$lib$shapes$Text\");\nmodule=require(\"module$node_modules$konva$lib$Validators\");require=require(\"module$node_modules$konva$lib$Global\");Shape_1=function(_super){function TextPath(config){var _this=_super.call(this,config)||this;_this.dummyCanvas=Util_1.Util.createCanvasElement();_this.dataArray=[];_this.dataArray=Path_1.Path.parsePathData(_this.attrs.data);_this.on(\"dataChange.konva\",function(){this.dataArray=Path_1.Path.parsePathData(this.attrs.data);this._setTextData()});_this.on(\"textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva\",\n_this._setTextData);config&&config.getKerning&&(Util_1.Util.warn('getKerning TextPath API is deprecated. Please use \"kerningFunc\" instead.'),_this.kerningFunc(config.getKerning));_this._setTextData();return _this}__extends(TextPath,_super);TextPath.prototype._sceneFunc=function(context){context.setAttr(\"font\",this._getContextFont());context.setAttr(\"textBaseline\",this.textBaseline());context.setAttr(\"textAlign\",\"left\");context.save();var textDecoration=this.textDecoration(),fill=this.fill(),fontSize=\nthis.fontSize(),glyphInfo=this.glyphInfo;\"underline\"===textDecoration&&context.beginPath();for(var i=0;i<glyphInfo.length;i++){context.save();var p0=glyphInfo[i].p0;context.translate(p0.x,p0.y);context.rotate(glyphInfo[i].rotation);this.partialText=glyphInfo[i].text;context.fillStrokeShape(this);\"underline\"===textDecoration&&(0===i&&context.moveTo(0,fontSize/2+1),context.lineTo(fontSize,fontSize/2+1));context.restore()}\"underline\"===textDecoration&&(context.strokeStyle=fill,context.lineWidth=fontSize/\n20,context.stroke());context.restore()};TextPath.prototype._hitFunc=function(context){context.beginPath();var glyphInfo=this.glyphInfo;if(1<=glyphInfo.length){var p0=glyphInfo[0].p0;context.moveTo(p0.x,p0.y)}for(p0=0;p0<glyphInfo.length;p0++){var p1=glyphInfo[p0].p1;context.lineTo(p1.x,p1.y)}context.setAttr(\"lineWidth\",this.fontSize());context.setAttr(\"strokeStyle\",this.colorKey);context.stroke()};TextPath.prototype.getTextWidth=function(){return this.textWidth};TextPath.prototype.getTextHeight=function(){Util_1.Util.warn(\"text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.\");\nreturn this.textHeight};TextPath.prototype.setText=function(text){return Text_1.Text.prototype.setText.call(this,text)};TextPath.prototype._getContextFont=function(){return Text_1.Text.prototype._getContextFont.call(this)};TextPath.prototype._getTextSize=function(text){var _context=this.dummyCanvas.getContext(\"2d\");_context.save();_context.font=this._getContextFont();text=_context.measureText(text);_context.restore();return{width:text.width,height:parseInt(this.attrs.fontSize,10)}};TextPath.prototype._setTextData=\nfunction(){var that=this,size=this._getTextSize(this.attrs.text),letterSpacing=this.letterSpacing(),align=this.align(),kerningFunc=this.kerningFunc();this.textWidth=size.width;this.textHeight=size.height;var textFullWidth=Math.max(this.textWidth+((this.attrs.text||\"\").length-1)*letterSpacing,0);this.glyphInfo=[];var fullPathWidth=0;for(size=0;size<that.dataArray.length;size++)0<that.dataArray[size].pathLength&&(fullPathWidth+=that.dataArray[size].pathLength);var offset=0;\"center\"===align&&(offset=\nMath.max(0,fullPathWidth/2-textFullWidth/2));\"right\"===align&&(offset=Math.max(0,fullPathWidth-textFullWidth));size=this.text().split(\"\");for(var spacesNumber=this.text().split(\" \").length-1,p0,p1,pathCmd,pIndex=-1,currentT=0,findSegmentToFitCharacter=function(c){var glyphWidth=that._getTextSize(c).width+letterSpacing;\" \"===c&&\"justify\"===align&&(glyphWidth+=(fullPathWidth-textFullWidth)/spacesNumber);var attempts=c=0;for(p1=void 0;.01<Math.abs(glyphWidth-c)/glyphWidth&&25>attempts;){attempts++;for(var cumulativePathLength=\nc;void 0===pathCmd;){a:{currentT=0;for(var pathData=that.dataArray,j=pIndex+1;j<pathData.length;j++)if(0<pathData[j].pathLength){pIndex=j;pathCmd=pathData[j];break a}else\"M\"===pathData[j].command&&(p0={x:pathData[j].points[0],y:pathData[j].points[1]});pathCmd={}}pathCmd&&cumulativePathLength+pathCmd.pathLength<glyphWidth&&(cumulativePathLength+=pathCmd.pathLength,pathCmd=void 0)}if(pathCmd==={}||void 0===p0)break;cumulativePathLength=!1;switch(pathCmd.command){case \"L\":Path_1.Path.getLineLength(p0.x,\np0.y,pathCmd.points[0],pathCmd.points[1])>glyphWidth?p1=Path_1.Path.getPointOnLine(glyphWidth,p0.x,p0.y,pathCmd.points[0],pathCmd.points[1],p0.x,p0.y):pathCmd=void 0;break;case \"A\":pathData=pathCmd.points[4];j=pathCmd.points[5];var end=pathCmd.points[4]+j;currentT=0===currentT?pathData+1E-8:glyphWidth>c?currentT+Math.PI/180*j/Math.abs(j):currentT-Math.PI/360*j/Math.abs(j);if(0>j&&currentT<end||0<=j&&currentT>end)currentT=end,cumulativePathLength=!0;p1=Path_1.Path.getPointOnEllipticalArc(pathCmd.points[0],\npathCmd.points[1],pathCmd.points[2],pathCmd.points[3],currentT,pathCmd.points[6]);break;case \"C\":currentT=0===currentT?glyphWidth>pathCmd.pathLength?1E-8:glyphWidth/pathCmd.pathLength:glyphWidth>c?currentT+(glyphWidth-c)/pathCmd.pathLength:currentT-(c-glyphWidth)/pathCmd.pathLength;1<currentT&&(currentT=1,cumulativePathLength=!0);p1=Path_1.Path.getPointOnCubicBezier(currentT,pathCmd.start.x,pathCmd.start.y,pathCmd.points[0],pathCmd.points[1],pathCmd.points[2],pathCmd.points[3],pathCmd.points[4],pathCmd.points[5]);\nbreak;case \"Q\":currentT=0===currentT?glyphWidth/pathCmd.pathLength:glyphWidth>c?currentT+(glyphWidth-c)/pathCmd.pathLength:currentT-(c-glyphWidth)/pathCmd.pathLength,1<currentT&&(currentT=1,cumulativePathLength=!0),p1=Path_1.Path.getPointOnQuadraticBezier(currentT,pathCmd.start.x,pathCmd.start.y,pathCmd.points[0],pathCmd.points[1],pathCmd.points[2],pathCmd.points[3])}void 0!==p1&&(c=Path_1.Path.getLineLength(p0.x,p0.y,p1.x,p1.y));cumulativePathLength&&(pathCmd=void 0)}},glyphWidth=that._getTextSize(\"C\").width+\nletterSpacing,k=0;k<offset/glyphWidth;k++){findSegmentToFitCharacter(\"C\");if(void 0===p0||void 0===p1)break;p0=p1}for(offset=0;offset<size.length;offset++){findSegmentToFitCharacter(size[offset]);if(void 0===p0||void 0===p1)break;glyphWidth=Path_1.Path.getLineLength(p0.x,p0.y,p1.x,p1.y);k=0;if(kerningFunc)try{k=kerningFunc(size[offset-1],size[offset])*this.fontSize()}catch(e){k=0}p0.x+=k;p1.x+=k;this.textWidth+=k;glyphWidth=Path_1.Path.getPointOnLine(k+glyphWidth/2,p0.x,p0.y,p1.x,p1.y);this.glyphInfo.push({transposeX:glyphWidth.x,\ntransposeY:glyphWidth.y,text:size[offset],rotation:Math.atan2(p1.y-p0.y,p1.x-p0.x),p0:p0,p1:p1});p0=p1}};TextPath.prototype.getSelfRect=function(){var points=[];this.glyphInfo.forEach(function(info){points.push(info.p0.x);points.push(info.p0.y);points.push(info.p1.x);points.push(info.p1.y)});for(var minX=points[0],maxX=points[0],minY=points[0],maxY=points[0],x,y,i=0;i<points.length/2;i++)x=points[2*i],y=points[2*i+1],minX=Math.min(minX,x),maxX=Math.max(maxX,x),minY=Math.min(minY,y),maxY=Math.max(maxY,\ny);x=this.fontSize();return{x:Math.round(minX)-x/2,y:Math.round(minY)-x/2,width:Math.round(maxX-minX)+x,height:Math.round(maxY-minY)+x}};return TextPath}(Shape_1.Shape);exports.TextPath=Shape_1;Shape_1.prototype._fillFunc=_fillFunc;Shape_1.prototype._strokeFunc=_strokeFunc;Shape_1.prototype._fillFuncHit=_fillFunc;Shape_1.prototype._strokeFuncHit=_strokeFunc;Shape_1.prototype.className=\"TextPath\";Shape_1.prototype._attrsAffectingSize=[\"text\",\"fontSize\",\"data\"];require._registerNode(Shape_1);global.Factory.addGetterSetter(Shape_1,\n\"data\");global.Factory.addGetterSetter(Shape_1,\"fontFamily\",\"Arial\");global.Factory.addGetterSetter(Shape_1,\"fontSize\",12,module.getNumberValidator());global.Factory.addGetterSetter(Shape_1,\"fontStyle\",\"normal\");global.Factory.addGetterSetter(Shape_1,\"align\",\"left\");global.Factory.addGetterSetter(Shape_1,\"letterSpacing\",0,module.getNumberValidator());global.Factory.addGetterSetter(Shape_1,\"textBaseline\",\"middle\");global.Factory.addGetterSetter(Shape_1,\"fontVariant\",\"normal\");global.Factory.addGetterSetter(Shape_1,\n\"text\",\"\");global.Factory.addGetterSetter(Shape_1,\"textDecoration\",null);global.Factory.addGetterSetter(Shape_1,\"kerningFunc\",null);Util_1.Collection.mapMethods(Shape_1)}","~:source","shadow$provide[\"module$node_modules$konva$lib$shapes$TextPath\"] = function(global,require,module,exports) {\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Util_1 = require(\"../Util\");\nvar Factory_1 = require(\"../Factory\");\nvar Shape_1 = require(\"../Shape\");\nvar Path_1 = require(\"./Path\");\nvar Text_1 = require(\"./Text\");\nvar Validators_1 = require(\"../Validators\");\nvar Global_1 = require(\"../Global\");\nvar EMPTY_STRING = '', NORMAL = 'normal';\nfunction _fillFunc(context) {\n    context.fillText(this.partialText, 0, 0);\n}\nfunction _strokeFunc(context) {\n    context.strokeText(this.partialText, 0, 0);\n}\nvar TextPath = (function (_super) {\n    __extends(TextPath, _super);\n    function TextPath(config) {\n        var _this = _super.call(this, config) || this;\n        _this.dummyCanvas = Util_1.Util.createCanvasElement();\n        _this.dataArray = [];\n        _this.dataArray = Path_1.Path.parsePathData(_this.attrs.data);\n        _this.on('dataChange.konva', function () {\n            this.dataArray = Path_1.Path.parsePathData(this.attrs.data);\n            this._setTextData();\n        });\n        _this.on('textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva', _this._setTextData);\n        if (config && config['getKerning']) {\n            Util_1.Util.warn('getKerning TextPath API is deprecated. Please use \"kerningFunc\" instead.');\n            _this.kerningFunc(config['getKerning']);\n        }\n        _this._setTextData();\n        return _this;\n    }\n    TextPath.prototype._sceneFunc = function (context) {\n        context.setAttr('font', this._getContextFont());\n        context.setAttr('textBaseline', this.textBaseline());\n        context.setAttr('textAlign', 'left');\n        context.save();\n        var textDecoration = this.textDecoration();\n        var fill = this.fill();\n        var fontSize = this.fontSize();\n        var glyphInfo = this.glyphInfo;\n        if (textDecoration === 'underline') {\n            context.beginPath();\n        }\n        for (var i = 0; i < glyphInfo.length; i++) {\n            context.save();\n            var p0 = glyphInfo[i].p0;\n            context.translate(p0.x, p0.y);\n            context.rotate(glyphInfo[i].rotation);\n            this.partialText = glyphInfo[i].text;\n            context.fillStrokeShape(this);\n            if (textDecoration === 'underline') {\n                if (i === 0) {\n                    context.moveTo(0, fontSize / 2 + 1);\n                }\n                context.lineTo(fontSize, fontSize / 2 + 1);\n            }\n            context.restore();\n        }\n        if (textDecoration === 'underline') {\n            context.strokeStyle = fill;\n            context.lineWidth = fontSize / 20;\n            context.stroke();\n        }\n        context.restore();\n    };\n    TextPath.prototype._hitFunc = function (context) {\n        context.beginPath();\n        var glyphInfo = this.glyphInfo;\n        if (glyphInfo.length >= 1) {\n            var p0 = glyphInfo[0].p0;\n            context.moveTo(p0.x, p0.y);\n        }\n        for (var i = 0; i < glyphInfo.length; i++) {\n            var p1 = glyphInfo[i].p1;\n            context.lineTo(p1.x, p1.y);\n        }\n        context.setAttr('lineWidth', this.fontSize());\n        context.setAttr('strokeStyle', this.colorKey);\n        context.stroke();\n    };\n    TextPath.prototype.getTextWidth = function () {\n        return this.textWidth;\n    };\n    TextPath.prototype.getTextHeight = function () {\n        Util_1.Util.warn('text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.');\n        return this.textHeight;\n    };\n    TextPath.prototype.setText = function (text) {\n        return Text_1.Text.prototype.setText.call(this, text);\n    };\n    TextPath.prototype._getContextFont = function () {\n        return Text_1.Text.prototype._getContextFont.call(this);\n    };\n    TextPath.prototype._getTextSize = function (text) {\n        var dummyCanvas = this.dummyCanvas;\n        var _context = dummyCanvas.getContext('2d');\n        _context.save();\n        _context.font = this._getContextFont();\n        var metrics = _context.measureText(text);\n        _context.restore();\n        return {\n            width: metrics.width,\n            height: parseInt(this.attrs.fontSize, 10)\n        };\n    };\n    TextPath.prototype._setTextData = function () {\n        var that = this;\n        var size = this._getTextSize(this.attrs.text);\n        var letterSpacing = this.letterSpacing();\n        var align = this.align();\n        var kerningFunc = this.kerningFunc();\n        this.textWidth = size.width;\n        this.textHeight = size.height;\n        var textFullWidth = Math.max(this.textWidth + ((this.attrs.text || '').length - 1) * letterSpacing, 0);\n        this.glyphInfo = [];\n        var fullPathWidth = 0;\n        for (var l = 0; l < that.dataArray.length; l++) {\n            if (that.dataArray[l].pathLength > 0) {\n                fullPathWidth += that.dataArray[l].pathLength;\n            }\n        }\n        var offset = 0;\n        if (align === 'center') {\n            offset = Math.max(0, fullPathWidth / 2 - textFullWidth / 2);\n        }\n        if (align === 'right') {\n            offset = Math.max(0, fullPathWidth - textFullWidth);\n        }\n        var charArr = this.text().split('');\n        var spacesNumber = this.text().split(' ').length - 1;\n        var p0, p1, pathCmd;\n        var pIndex = -1;\n        var currentT = 0;\n        var getNextPathSegment = function () {\n            currentT = 0;\n            var pathData = that.dataArray;\n            for (var j = pIndex + 1; j < pathData.length; j++) {\n                if (pathData[j].pathLength > 0) {\n                    pIndex = j;\n                    return pathData[j];\n                }\n                else if (pathData[j].command === 'M') {\n                    p0 = {\n                        x: pathData[j].points[0],\n                        y: pathData[j].points[1]\n                    };\n                }\n            }\n            return {};\n        };\n        var findSegmentToFitCharacter = function (c) {\n            var glyphWidth = that._getTextSize(c).width + letterSpacing;\n            if (c === ' ' && align === 'justify') {\n                glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;\n            }\n            var currLen = 0;\n            var attempts = 0;\n            p1 = undefined;\n            while (Math.abs(glyphWidth - currLen) / glyphWidth > 0.01 &&\n                attempts < 25) {\n                attempts++;\n                var cumulativePathLength = currLen;\n                while (pathCmd === undefined) {\n                    pathCmd = getNextPathSegment();\n                    if (pathCmd &&\n                        cumulativePathLength + pathCmd.pathLength < glyphWidth) {\n                        cumulativePathLength += pathCmd.pathLength;\n                        pathCmd = undefined;\n                    }\n                }\n                if (pathCmd === {} || p0 === undefined) {\n                    return undefined;\n                }\n                var needNewSegment = false;\n                switch (pathCmd.command) {\n                    case 'L':\n                        if (Path_1.Path.getLineLength(p0.x, p0.y, pathCmd.points[0], pathCmd.points[1]) > glyphWidth) {\n                            p1 = Path_1.Path.getPointOnLine(glyphWidth, p0.x, p0.y, pathCmd.points[0], pathCmd.points[1], p0.x, p0.y);\n                        }\n                        else {\n                            pathCmd = undefined;\n                        }\n                        break;\n                    case 'A':\n                        var start = pathCmd.points[4];\n                        var dTheta = pathCmd.points[5];\n                        var end = pathCmd.points[4] + dTheta;\n                        if (currentT === 0) {\n                            currentT = start + 0.00000001;\n                        }\n                        else if (glyphWidth > currLen) {\n                            currentT += ((Math.PI / 180.0) * dTheta) / Math.abs(dTheta);\n                        }\n                        else {\n                            currentT -= ((Math.PI / 360.0) * dTheta) / Math.abs(dTheta);\n                        }\n                        if ((dTheta < 0 && currentT < end) ||\n                            (dTheta >= 0 && currentT > end)) {\n                            currentT = end;\n                            needNewSegment = true;\n                        }\n                        p1 = Path_1.Path.getPointOnEllipticalArc(pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], currentT, pathCmd.points[6]);\n                        break;\n                    case 'C':\n                        if (currentT === 0) {\n                            if (glyphWidth > pathCmd.pathLength) {\n                                currentT = 0.00000001;\n                            }\n                            else {\n                                currentT = glyphWidth / pathCmd.pathLength;\n                            }\n                        }\n                        else if (glyphWidth > currLen) {\n                            currentT += (glyphWidth - currLen) / pathCmd.pathLength;\n                        }\n                        else {\n                            currentT -= (currLen - glyphWidth) / pathCmd.pathLength;\n                        }\n                        if (currentT > 1.0) {\n                            currentT = 1.0;\n                            needNewSegment = true;\n                        }\n                        p1 = Path_1.Path.getPointOnCubicBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], pathCmd.points[4], pathCmd.points[5]);\n                        break;\n                    case 'Q':\n                        if (currentT === 0) {\n                            currentT = glyphWidth / pathCmd.pathLength;\n                        }\n                        else if (glyphWidth > currLen) {\n                            currentT += (glyphWidth - currLen) / pathCmd.pathLength;\n                        }\n                        else {\n                            currentT -= (currLen - glyphWidth) / pathCmd.pathLength;\n                        }\n                        if (currentT > 1.0) {\n                            currentT = 1.0;\n                            needNewSegment = true;\n                        }\n                        p1 = Path_1.Path.getPointOnQuadraticBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3]);\n                        break;\n                }\n                if (p1 !== undefined) {\n                    currLen = Path_1.Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n                }\n                if (needNewSegment) {\n                    needNewSegment = false;\n                    pathCmd = undefined;\n                }\n            }\n        };\n        var testChar = 'C';\n        var glyphWidth = that._getTextSize(testChar).width + letterSpacing;\n        for (var k = 0; k < offset / glyphWidth; k++) {\n            findSegmentToFitCharacter(testChar);\n            if (p0 === undefined || p1 === undefined) {\n                break;\n            }\n            p0 = p1;\n        }\n        for (var i = 0; i < charArr.length; i++) {\n            findSegmentToFitCharacter(charArr[i]);\n            if (p0 === undefined || p1 === undefined) {\n                break;\n            }\n            var width = Path_1.Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n            var kern = 0;\n            if (kerningFunc) {\n                try {\n                    kern = kerningFunc(charArr[i - 1], charArr[i]) * this.fontSize();\n                }\n                catch (e) {\n                    kern = 0;\n                }\n            }\n            p0.x += kern;\n            p1.x += kern;\n            this.textWidth += kern;\n            var midpoint = Path_1.Path.getPointOnLine(kern + width / 2.0, p0.x, p0.y, p1.x, p1.y);\n            var rotation = Math.atan2(p1.y - p0.y, p1.x - p0.x);\n            this.glyphInfo.push({\n                transposeX: midpoint.x,\n                transposeY: midpoint.y,\n                text: charArr[i],\n                rotation: rotation,\n                p0: p0,\n                p1: p1\n            });\n            p0 = p1;\n        }\n    };\n    TextPath.prototype.getSelfRect = function () {\n        var points = [];\n        this.glyphInfo.forEach(function (info) {\n            points.push(info.p0.x);\n            points.push(info.p0.y);\n            points.push(info.p1.x);\n            points.push(info.p1.y);\n        });\n        var minX = points[0];\n        var maxX = points[0];\n        var minY = points[0];\n        var maxY = points[0];\n        var x, y;\n        for (var i = 0; i < points.length / 2; i++) {\n            x = points[i * 2];\n            y = points[i * 2 + 1];\n            minX = Math.min(minX, x);\n            maxX = Math.max(maxX, x);\n            minY = Math.min(minY, y);\n            maxY = Math.max(maxY, y);\n        }\n        var fontSize = this.fontSize();\n        return {\n            x: Math.round(minX) - fontSize / 2,\n            y: Math.round(minY) - fontSize / 2,\n            width: Math.round(maxX - minX) + fontSize,\n            height: Math.round(maxY - minY) + fontSize\n        };\n    };\n    return TextPath;\n}(Shape_1.Shape));\nexports.TextPath = TextPath;\nTextPath.prototype._fillFunc = _fillFunc;\nTextPath.prototype._strokeFunc = _strokeFunc;\nTextPath.prototype._fillFuncHit = _fillFunc;\nTextPath.prototype._strokeFuncHit = _strokeFunc;\nTextPath.prototype.className = 'TextPath';\nTextPath.prototype._attrsAffectingSize = ['text', 'fontSize', 'data'];\nGlobal_1._registerNode(TextPath);\nFactory_1.Factory.addGetterSetter(TextPath, 'data');\nFactory_1.Factory.addGetterSetter(TextPath, 'fontFamily', 'Arial');\nFactory_1.Factory.addGetterSetter(TextPath, 'fontSize', 12, Validators_1.getNumberValidator());\nFactory_1.Factory.addGetterSetter(TextPath, 'fontStyle', NORMAL);\nFactory_1.Factory.addGetterSetter(TextPath, 'align', 'left');\nFactory_1.Factory.addGetterSetter(TextPath, 'letterSpacing', 0, Validators_1.getNumberValidator());\nFactory_1.Factory.addGetterSetter(TextPath, 'textBaseline', 'middle');\nFactory_1.Factory.addGetterSetter(TextPath, 'fontVariant', NORMAL);\nFactory_1.Factory.addGetterSetter(TextPath, 'text', EMPTY_STRING);\nFactory_1.Factory.addGetterSetter(TextPath, 'textDecoration', null);\nFactory_1.Factory.addGetterSetter(TextPath, 'kerningFunc', null);\nUtil_1.Collection.mapMethods(TextPath);\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$konva$lib$Factory","~$module$node_modules$konva$lib$shapes$Path","~$module$node_modules$konva$lib$Validators","~$module$node_modules$konva$lib$shapes$Text","~$shadow.js","~$module$node_modules$konva$lib$Global","~$module$node_modules$konva$lib$Shape","~$module$node_modules$konva$lib$Util"]],"~:properties",["^5",["width","lineWidth","TextPath","_fillFuncHit","prototype","height","_strokeFunc","partialText","setText","getTextWidth","className","glyphInfo","getSelfRect","x","__esModule","textHeight","_getContextFont","_sceneFunc","getTextHeight","p0","value","transposeX","textWidth","text","rotation","font","_hitFunc","dummyCanvas","y","__proto__","_fillFunc","_attrsAffectingSize","p1","_setTextData","strokeStyle","_strokeFuncHit","_getTextSize","transposeY","dataArray","constructor"]],"~:compiled-at",1568562085511,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$konva$lib$shapes$TextPath.js\",\n\"lineCount\":18,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/konva/lib/shapes/TextPath.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$konva$lib$shapes$TextPath\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nvar __extends = (this && this.__extends) || (function () {\\n    var extendStatics = function (d, b) {\\n        extendStatics = Object.setPrototypeOf ||\\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\\n        return extendStatics(d, b);\\n    };\\n    return function (d, b) {\\n        extendStatics(d, b);\\n        function __() { this.constructor = d; }\\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\\n    };\\n})();\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nvar Util_1 = require(\\\"../Util\\\");\\nvar Factory_1 = require(\\\"../Factory\\\");\\nvar Shape_1 = require(\\\"../Shape\\\");\\nvar Path_1 = require(\\\"./Path\\\");\\nvar Text_1 = require(\\\"./Text\\\");\\nvar Validators_1 = require(\\\"../Validators\\\");\\nvar Global_1 = require(\\\"../Global\\\");\\nvar EMPTY_STRING = '', NORMAL = 'normal';\\nfunction _fillFunc(context) {\\n    context.fillText(this.partialText, 0, 0);\\n}\\nfunction _strokeFunc(context) {\\n    context.strokeText(this.partialText, 0, 0);\\n}\\nvar TextPath = (function (_super) {\\n    __extends(TextPath, _super);\\n    function TextPath(config) {\\n        var _this = _super.call(this, config) || this;\\n        _this.dummyCanvas = Util_1.Util.createCanvasElement();\\n        _this.dataArray = [];\\n        _this.dataArray = Path_1.Path.parsePathData(_this.attrs.data);\\n        _this.on('dataChange.konva', function () {\\n            this.dataArray = Path_1.Path.parsePathData(this.attrs.data);\\n            this._setTextData();\\n        });\\n        _this.on('textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva', _this._setTextData);\\n        if (config && config['getKerning']) {\\n            Util_1.Util.warn('getKerning TextPath API is deprecated. Please use \\\"kerningFunc\\\" instead.');\\n            _this.kerningFunc(config['getKerning']);\\n        }\\n        _this._setTextData();\\n        return _this;\\n    }\\n    TextPath.prototype._sceneFunc = function (context) {\\n        context.setAttr('font', this._getContextFont());\\n        context.setAttr('textBaseline', this.textBaseline());\\n        context.setAttr('textAlign', 'left');\\n        context.save();\\n        var textDecoration = this.textDecoration();\\n        var fill = this.fill();\\n        var fontSize = this.fontSize();\\n        var glyphInfo = this.glyphInfo;\\n        if (textDecoration === 'underline') {\\n            context.beginPath();\\n        }\\n        for (var i = 0; i < glyphInfo.length; i++) {\\n            context.save();\\n            var p0 = glyphInfo[i].p0;\\n            context.translate(p0.x, p0.y);\\n            context.rotate(glyphInfo[i].rotation);\\n            this.partialText = glyphInfo[i].text;\\n            context.fillStrokeShape(this);\\n            if (textDecoration === 'underline') {\\n                if (i === 0) {\\n                    context.moveTo(0, fontSize / 2 + 1);\\n                }\\n                context.lineTo(fontSize, fontSize / 2 + 1);\\n            }\\n            context.restore();\\n        }\\n        if (textDecoration === 'underline') {\\n            context.strokeStyle = fill;\\n            context.lineWidth = fontSize / 20;\\n            context.stroke();\\n        }\\n        context.restore();\\n    };\\n    TextPath.prototype._hitFunc = function (context) {\\n        context.beginPath();\\n        var glyphInfo = this.glyphInfo;\\n        if (glyphInfo.length >= 1) {\\n            var p0 = glyphInfo[0].p0;\\n            context.moveTo(p0.x, p0.y);\\n        }\\n        for (var i = 0; i < glyphInfo.length; i++) {\\n            var p1 = glyphInfo[i].p1;\\n            context.lineTo(p1.x, p1.y);\\n        }\\n        context.setAttr('lineWidth', this.fontSize());\\n        context.setAttr('strokeStyle', this.colorKey);\\n        context.stroke();\\n    };\\n    TextPath.prototype.getTextWidth = function () {\\n        return this.textWidth;\\n    };\\n    TextPath.prototype.getTextHeight = function () {\\n        Util_1.Util.warn('text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.');\\n        return this.textHeight;\\n    };\\n    TextPath.prototype.setText = function (text) {\\n        return Text_1.Text.prototype.setText.call(this, text);\\n    };\\n    TextPath.prototype._getContextFont = function () {\\n        return Text_1.Text.prototype._getContextFont.call(this);\\n    };\\n    TextPath.prototype._getTextSize = function (text) {\\n        var dummyCanvas = this.dummyCanvas;\\n        var _context = dummyCanvas.getContext('2d');\\n        _context.save();\\n        _context.font = this._getContextFont();\\n        var metrics = _context.measureText(text);\\n        _context.restore();\\n        return {\\n            width: metrics.width,\\n            height: parseInt(this.attrs.fontSize, 10)\\n        };\\n    };\\n    TextPath.prototype._setTextData = function () {\\n        var that = this;\\n        var size = this._getTextSize(this.attrs.text);\\n        var letterSpacing = this.letterSpacing();\\n        var align = this.align();\\n        var kerningFunc = this.kerningFunc();\\n        this.textWidth = size.width;\\n        this.textHeight = size.height;\\n        var textFullWidth = Math.max(this.textWidth + ((this.attrs.text || '').length - 1) * letterSpacing, 0);\\n        this.glyphInfo = [];\\n        var fullPathWidth = 0;\\n        for (var l = 0; l < that.dataArray.length; l++) {\\n            if (that.dataArray[l].pathLength > 0) {\\n                fullPathWidth += that.dataArray[l].pathLength;\\n            }\\n        }\\n        var offset = 0;\\n        if (align === 'center') {\\n            offset = Math.max(0, fullPathWidth / 2 - textFullWidth / 2);\\n        }\\n        if (align === 'right') {\\n            offset = Math.max(0, fullPathWidth - textFullWidth);\\n        }\\n        var charArr = this.text().split('');\\n        var spacesNumber = this.text().split(' ').length - 1;\\n        var p0, p1, pathCmd;\\n        var pIndex = -1;\\n        var currentT = 0;\\n        var getNextPathSegment = function () {\\n            currentT = 0;\\n            var pathData = that.dataArray;\\n            for (var j = pIndex + 1; j < pathData.length; j++) {\\n                if (pathData[j].pathLength > 0) {\\n                    pIndex = j;\\n                    return pathData[j];\\n                }\\n                else if (pathData[j].command === 'M') {\\n                    p0 = {\\n                        x: pathData[j].points[0],\\n                        y: pathData[j].points[1]\\n                    };\\n                }\\n            }\\n            return {};\\n        };\\n        var findSegmentToFitCharacter = function (c) {\\n            var glyphWidth = that._getTextSize(c).width + letterSpacing;\\n            if (c === ' ' && align === 'justify') {\\n                glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;\\n            }\\n            var currLen = 0;\\n            var attempts = 0;\\n            p1 = undefined;\\n            while (Math.abs(glyphWidth - currLen) / glyphWidth > 0.01 &&\\n                attempts < 25) {\\n                attempts++;\\n                var cumulativePathLength = currLen;\\n                while (pathCmd === undefined) {\\n                    pathCmd = getNextPathSegment();\\n                    if (pathCmd &&\\n                        cumulativePathLength + pathCmd.pathLength < glyphWidth) {\\n                        cumulativePathLength += pathCmd.pathLength;\\n                        pathCmd = undefined;\\n                    }\\n                }\\n                if (pathCmd === {} || p0 === undefined) {\\n                    return undefined;\\n                }\\n                var needNewSegment = false;\\n                switch (pathCmd.command) {\\n                    case 'L':\\n                        if (Path_1.Path.getLineLength(p0.x, p0.y, pathCmd.points[0], pathCmd.points[1]) > glyphWidth) {\\n                            p1 = Path_1.Path.getPointOnLine(glyphWidth, p0.x, p0.y, pathCmd.points[0], pathCmd.points[1], p0.x, p0.y);\\n                        }\\n                        else {\\n                            pathCmd = undefined;\\n                        }\\n                        break;\\n                    case 'A':\\n                        var start = pathCmd.points[4];\\n                        var dTheta = pathCmd.points[5];\\n                        var end = pathCmd.points[4] + dTheta;\\n                        if (currentT === 0) {\\n                            currentT = start + 0.00000001;\\n                        }\\n                        else if (glyphWidth > currLen) {\\n                            currentT += ((Math.PI / 180.0) * dTheta) / Math.abs(dTheta);\\n                        }\\n                        else {\\n                            currentT -= ((Math.PI / 360.0) * dTheta) / Math.abs(dTheta);\\n                        }\\n                        if ((dTheta < 0 && currentT < end) ||\\n                            (dTheta >= 0 && currentT > end)) {\\n                            currentT = end;\\n                            needNewSegment = true;\\n                        }\\n                        p1 = Path_1.Path.getPointOnEllipticalArc(pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], currentT, pathCmd.points[6]);\\n                        break;\\n                    case 'C':\\n                        if (currentT === 0) {\\n                            if (glyphWidth > pathCmd.pathLength) {\\n                                currentT = 0.00000001;\\n                            }\\n                            else {\\n                                currentT = glyphWidth / pathCmd.pathLength;\\n                            }\\n                        }\\n                        else if (glyphWidth > currLen) {\\n                            currentT += (glyphWidth - currLen) / pathCmd.pathLength;\\n                        }\\n                        else {\\n                            currentT -= (currLen - glyphWidth) / pathCmd.pathLength;\\n                        }\\n                        if (currentT > 1.0) {\\n                            currentT = 1.0;\\n                            needNewSegment = true;\\n                        }\\n                        p1 = Path_1.Path.getPointOnCubicBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], pathCmd.points[4], pathCmd.points[5]);\\n                        break;\\n                    case 'Q':\\n                        if (currentT === 0) {\\n                            currentT = glyphWidth / pathCmd.pathLength;\\n                        }\\n                        else if (glyphWidth > currLen) {\\n                            currentT += (glyphWidth - currLen) / pathCmd.pathLength;\\n                        }\\n                        else {\\n                            currentT -= (currLen - glyphWidth) / pathCmd.pathLength;\\n                        }\\n                        if (currentT > 1.0) {\\n                            currentT = 1.0;\\n                            needNewSegment = true;\\n                        }\\n                        p1 = Path_1.Path.getPointOnQuadraticBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3]);\\n                        break;\\n                }\\n                if (p1 !== undefined) {\\n                    currLen = Path_1.Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\\n                }\\n                if (needNewSegment) {\\n                    needNewSegment = false;\\n                    pathCmd = undefined;\\n                }\\n            }\\n        };\\n        var testChar = 'C';\\n        var glyphWidth = that._getTextSize(testChar).width + letterSpacing;\\n        for (var k = 0; k < offset / glyphWidth; k++) {\\n            findSegmentToFitCharacter(testChar);\\n            if (p0 === undefined || p1 === undefined) {\\n                break;\\n            }\\n            p0 = p1;\\n        }\\n        for (var i = 0; i < charArr.length; i++) {\\n            findSegmentToFitCharacter(charArr[i]);\\n            if (p0 === undefined || p1 === undefined) {\\n                break;\\n            }\\n            var width = Path_1.Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\\n            var kern = 0;\\n            if (kerningFunc) {\\n                try {\\n                    kern = kerningFunc(charArr[i - 1], charArr[i]) * this.fontSize();\\n                }\\n                catch (e) {\\n                    kern = 0;\\n                }\\n            }\\n            p0.x += kern;\\n            p1.x += kern;\\n            this.textWidth += kern;\\n            var midpoint = Path_1.Path.getPointOnLine(kern + width / 2.0, p0.x, p0.y, p1.x, p1.y);\\n            var rotation = Math.atan2(p1.y - p0.y, p1.x - p0.x);\\n            this.glyphInfo.push({\\n                transposeX: midpoint.x,\\n                transposeY: midpoint.y,\\n                text: charArr[i],\\n                rotation: rotation,\\n                p0: p0,\\n                p1: p1\\n            });\\n            p0 = p1;\\n        }\\n    };\\n    TextPath.prototype.getSelfRect = function () {\\n        var points = [];\\n        this.glyphInfo.forEach(function (info) {\\n            points.push(info.p0.x);\\n            points.push(info.p0.y);\\n            points.push(info.p1.x);\\n            points.push(info.p1.y);\\n        });\\n        var minX = points[0];\\n        var maxX = points[0];\\n        var minY = points[0];\\n        var maxY = points[0];\\n        var x, y;\\n        for (var i = 0; i < points.length / 2; i++) {\\n            x = points[i * 2];\\n            y = points[i * 2 + 1];\\n            minX = Math.min(minX, x);\\n            maxX = Math.max(maxX, x);\\n            minY = Math.min(minY, y);\\n            maxY = Math.max(maxY, y);\\n        }\\n        var fontSize = this.fontSize();\\n        return {\\n            x: Math.round(minX) - fontSize / 2,\\n            y: Math.round(minY) - fontSize / 2,\\n            width: Math.round(maxX - minX) + fontSize,\\n            height: Math.round(maxY - minY) + fontSize\\n        };\\n    };\\n    return TextPath;\\n}(Shape_1.Shape));\\nexports.TextPath = TextPath;\\nTextPath.prototype._fillFunc = _fillFunc;\\nTextPath.prototype._strokeFunc = _strokeFunc;\\nTextPath.prototype._fillFuncHit = _fillFunc;\\nTextPath.prototype._strokeFuncHit = _strokeFunc;\\nTextPath.prototype.className = 'TextPath';\\nTextPath.prototype._attrsAffectingSize = ['text', 'fontSize', 'data'];\\nGlobal_1._registerNode(TextPath);\\nFactory_1.Factory.addGetterSetter(TextPath, 'data');\\nFactory_1.Factory.addGetterSetter(TextPath, 'fontFamily', 'Arial');\\nFactory_1.Factory.addGetterSetter(TextPath, 'fontSize', 12, Validators_1.getNumberValidator());\\nFactory_1.Factory.addGetterSetter(TextPath, 'fontStyle', NORMAL);\\nFactory_1.Factory.addGetterSetter(TextPath, 'align', 'left');\\nFactory_1.Factory.addGetterSetter(TextPath, 'letterSpacing', 0, Validators_1.getNumberValidator());\\nFactory_1.Factory.addGetterSetter(TextPath, 'textBaseline', 'middle');\\nFactory_1.Factory.addGetterSetter(TextPath, 'fontVariant', NORMAL);\\nFactory_1.Factory.addGetterSetter(TextPath, 'text', EMPTY_STRING);\\nFactory_1.Factory.addGetterSetter(TextPath, 'textDecoration', null);\\nFactory_1.Factory.addGetterSetter(TextPath, 'kerningFunc', null);\\nUtil_1.Collection.mapMethods(TextPath);\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_fillFunc\",\"context\",\"fillText\",\"partialText\",\"_strokeFunc\",\"strokeText\",\"__extends\",\"extendStatics\",\"d\",\"b\",\"Object\",\"setPrototypeOf\",\"__proto__\",\"Array\",\"p\",\"hasOwnProperty\",\"__\",\"constructor\",\"prototype\",\"create\",\"defineProperty\",\"value\",\"Util_1\",\"Factory_1\",\"Shape_1\",\"Path_1\",\"Text_1\",\"Validators_1\",\"Global_1\",\"TextPath\",\"_super\",\"config\",\"_this\",\"call\",\"dummyCanvas\",\"Util\",\"createCanvasElement\",\"dataArray\",\"Path\",\"parsePathData\",\"attrs\",\"data\",\"on\",\"_setTextData\",\"warn\",\"kerningFunc\",\"_sceneFunc\",\"TextPath.prototype._sceneFunc\",\"setAttr\",\"_getContextFont\",\"textBaseline\",\"save\",\"textDecoration\",\"fill\",\"fontSize\",\"glyphInfo\",\"beginPath\",\"i\",\"length\",\"p0\",\"translate\",\"x\",\"y\",\"rotate\",\"rotation\",\"text\",\"fillStrokeShape\",\"moveTo\",\"lineTo\",\"restore\",\"strokeStyle\",\"lineWidth\",\"stroke\",\"_hitFunc\",\"TextPath.prototype._hitFunc\",\"p1\",\"colorKey\",\"getTextWidth\",\"TextPath.prototype.getTextWidth\",\"textWidth\",\"getTextHeight\",\"TextPath.prototype.getTextHeight\",\"textHeight\",\"setText\",\"TextPath.prototype.setText\",\"Text\",\"TextPath.prototype._getContextFont\",\"_getTextSize\",\"TextPath.prototype._getTextSize\",\"_context\",\"getContext\",\"font\",\"metrics\",\"measureText\",\"width\",\"height\",\"parseInt\",\"TextPath.prototype._setTextData\",\"that\",\"size\",\"letterSpacing\",\"align\",\"textFullWidth\",\"Math\",\"max\",\"fullPathWidth\",\"l\",\"pathLength\",\"offset\",\"charArr\",\"split\",\"spacesNumber\",\"pathCmd\",\"pIndex\",\"currentT\",\"findSegmentToFitCharacter\",\"c\",\"glyphWidth\",\"attempts\",\"currLen\",\"undefined\",\"abs\",\"cumulativePathLength\",\"pathData\",\"j\",\"command\",\"points\",\"needNewSegment\",\"getLineLength\",\"getPointOnLine\",\"start\",\"dTheta\",\"end\",\"PI\",\"getPointOnEllipticalArc\",\"getPointOnCubicBezier\",\"getPointOnQuadraticBezier\",\"testChar\",\"k\",\"kern\",\"e\",\"midpoint\",\"push\",\"transposeX\",\"transposeY\",\"atan2\",\"getSelfRect\",\"TextPath.prototype.getSelfRect\",\"forEach\",\"info\",\"minX\",\"maxX\",\"minY\",\"maxY\",\"min\",\"round\",\"Shape\",\"_fillFuncHit\",\"_strokeFuncHit\",\"className\",\"_attrsAffectingSize\",\"_registerNode\",\"Factory\",\"addGetterSetter\",\"getNumberValidator\",\"NORMAL\",\"EMPTY_STRING\",\"Collection\",\"mapMethods\"]\n}\n"]