["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/konva/lib/Layer.js"],"~:js","shadow$provide[34]=function(n,e,t,k){var w=this&&this.__extends||function(){var a=function(b,c){a=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(a,b){a.__proto__=b}||function(a,b){for(var c in b)b.hasOwnProperty(c)&&(a[c]=b[c])};return a(b,c)};return function(b,c){function d(){this.constructor=b}a(b,c);b.prototype=null===c?Object.create(c):(d.prototype=c.prototype,new d)}}();Object.defineProperty(k,\"__esModule\",{value:!0});var v=e(22),x=e(29);n=e(24);var q=e(32),m=e(26),d=e(33);t=\ne(23);e=e(21);var b=[{x:0,y:0},{x:-1,y:-1},{x:1,y:-1},{x:1,y:1},{x:-1,y:1}],h=b.length,a=function(a){function c(){var b=null!==a&&a.apply(this,arguments)||this;b.hitCanvas=new m.HitCanvas({pixelRatio:1});return b}w(c,a);c.prototype._setCanvasSize=function(a,b){this.canvas.setSize(a,b);this.hitCanvas.setSize(a,b);this._checkSmooth()};c.prototype._validateAdd=function(a){a=a.getType();\"Group\"!==a&&\"Shape\"!==a&&v.Util.throw(\"You may only add groups and shapes to a layer.\")};c.prototype.getIntersection=\nfunction(a,c){var d,e;if(!this.hitGraphEnabled()||!this.isVisible())return null;var p=1;for(e=!1;;){for(d=0;d<h;d++){var r=b[d];r=this._getIntersection({x:a.x+r.x*p,y:a.y+r.y*p});if((e=r.shape)&&c)return e.findAncestor(c,!0);if(e)return e;e=!!r.antialiased;if(!r.antialiased)break}if(e)p+=1;else return null}};c.prototype._getIntersection=function(a){var b=this.hitCanvas.pixelRatio;a=this.hitCanvas.context.getImageData(Math.round(a.x*b),Math.round(a.y*b),1,1).data;b=a[3];return 255===b?(a=v.Util._rgbToHex(a[0],\na[1],a[2]),(a=d.shapes[\"#\"+a])?{shape:a}:{antialiased:!0}):0<b?{antialiased:!0}:{}};c.prototype.drawScene=function(a,b){var c=this.getLayer();a=a||c&&c.getCanvas();this._fire(\"beforeDraw\",{node:this});this.clearBeforeDraw()&&a.getContext().clear();x.Container.prototype.drawScene.call(this,a,b);this._fire(\"draw\",{node:this});return this};c.prototype.drawHit=function(a,b){var c=this.getLayer();a=a||c&&c.hitCanvas;c&&c.clearBeforeDraw()&&c.getHitCanvas().getContext().clear();x.Container.prototype.drawHit.call(this,\na,b);return this};c.prototype.clear=function(a){q.BaseLayer.prototype.clear.call(this,a);this.getHitCanvas().getContext().clear(a);return this};c.prototype.enableHitGraph=function(){this.hitGraphEnabled(!0);return this};c.prototype.disableHitGraph=function(){this.hitGraphEnabled(!1);return this};c.prototype.toggleHitCanvas=function(){if(this.parent){var a=this.parent;this.hitCanvas._canvas.parentNode?a.content.removeChild(this.hitCanvas._canvas):a.content.appendChild(this.hitCanvas._canvas)}};c.prototype.setSize=\nfunction(b){var c=b.width;b=b.height;a.prototype.setSize.call(this,{width:c,height:b});this.hitCanvas.setSize(c,b);return this};return c}(q.BaseLayer);k.Layer=a;a.prototype.nodeType=\"Layer\";e._registerNode(a);n.Factory.addGetterSetter(a,\"hitGraphEnabled\",!0,t.getBooleanValidator());v.Collection.mapMethods(a)}","~:source","shadow$provide[34] = function(global,require,module,exports) {\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Util_1 = require(\"./Util\");\nvar Container_1 = require(\"./Container\");\nvar Factory_1 = require(\"./Factory\");\nvar BaseLayer_1 = require(\"./BaseLayer\");\nvar Canvas_1 = require(\"./Canvas\");\nvar Shape_1 = require(\"./Shape\");\nvar Validators_1 = require(\"./Validators\");\nvar Global_1 = require(\"./Global\");\nvar HASH = '#', BEFORE_DRAW = 'beforeDraw', DRAW = 'draw', INTERSECTION_OFFSETS = [\n    { x: 0, y: 0 },\n    { x: -1, y: -1 },\n    { x: 1, y: -1 },\n    { x: 1, y: 1 },\n    { x: -1, y: 1 }\n], INTERSECTION_OFFSETS_LEN = INTERSECTION_OFFSETS.length;\nvar Layer = (function (_super) {\n    __extends(Layer, _super);\n    function Layer() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.hitCanvas = new Canvas_1.HitCanvas({\n            pixelRatio: 1\n        });\n        return _this;\n    }\n    Layer.prototype._setCanvasSize = function (width, height) {\n        this.canvas.setSize(width, height);\n        this.hitCanvas.setSize(width, height);\n        this._checkSmooth();\n    };\n    Layer.prototype._validateAdd = function (child) {\n        var type = child.getType();\n        if (type !== 'Group' && type !== 'Shape') {\n            Util_1.Util.throw('You may only add groups and shapes to a layer.');\n        }\n    };\n    Layer.prototype.getIntersection = function (pos, selector) {\n        var obj, i, intersectionOffset, shape;\n        if (!this.hitGraphEnabled() || !this.isVisible()) {\n            return null;\n        }\n        var spiralSearchDistance = 1;\n        var continueSearch = false;\n        while (true) {\n            for (i = 0; i < INTERSECTION_OFFSETS_LEN; i++) {\n                intersectionOffset = INTERSECTION_OFFSETS[i];\n                obj = this._getIntersection({\n                    x: pos.x + intersectionOffset.x * spiralSearchDistance,\n                    y: pos.y + intersectionOffset.y * spiralSearchDistance\n                });\n                shape = obj.shape;\n                if (shape && selector) {\n                    return shape.findAncestor(selector, true);\n                }\n                else if (shape) {\n                    return shape;\n                }\n                continueSearch = !!obj.antialiased;\n                if (!obj.antialiased) {\n                    break;\n                }\n            }\n            if (continueSearch) {\n                spiralSearchDistance += 1;\n            }\n            else {\n                return null;\n            }\n        }\n    };\n    Layer.prototype._getIntersection = function (pos) {\n        var ratio = this.hitCanvas.pixelRatio;\n        var p = this.hitCanvas.context.getImageData(Math.round(pos.x * ratio), Math.round(pos.y * ratio), 1, 1).data, p3 = p[3], colorKey, shape;\n        if (p3 === 255) {\n            colorKey = Util_1.Util._rgbToHex(p[0], p[1], p[2]);\n            shape = Shape_1.shapes[HASH + colorKey];\n            if (shape) {\n                return {\n                    shape: shape\n                };\n            }\n            return {\n                antialiased: true\n            };\n        }\n        else if (p3 > 0) {\n            return {\n                antialiased: true\n            };\n        }\n        return {};\n    };\n    Layer.prototype.drawScene = function (can, top) {\n        var layer = this.getLayer(), canvas = can || (layer && layer.getCanvas());\n        this._fire(BEFORE_DRAW, {\n            node: this\n        });\n        if (this.clearBeforeDraw()) {\n            canvas.getContext().clear();\n        }\n        Container_1.Container.prototype.drawScene.call(this, canvas, top);\n        this._fire(DRAW, {\n            node: this\n        });\n        return this;\n    };\n    Layer.prototype.drawHit = function (can, top) {\n        var layer = this.getLayer(), canvas = can || (layer && layer.hitCanvas);\n        if (layer && layer.clearBeforeDraw()) {\n            layer\n                .getHitCanvas()\n                .getContext()\n                .clear();\n        }\n        Container_1.Container.prototype.drawHit.call(this, canvas, top);\n        return this;\n    };\n    Layer.prototype.clear = function (bounds) {\n        BaseLayer_1.BaseLayer.prototype.clear.call(this, bounds);\n        this.getHitCanvas()\n            .getContext()\n            .clear(bounds);\n        return this;\n    };\n    Layer.prototype.enableHitGraph = function () {\n        this.hitGraphEnabled(true);\n        return this;\n    };\n    Layer.prototype.disableHitGraph = function () {\n        this.hitGraphEnabled(false);\n        return this;\n    };\n    Layer.prototype.toggleHitCanvas = function () {\n        if (!this.parent) {\n            return;\n        }\n        var parent = this.parent;\n        var added = !!this.hitCanvas._canvas.parentNode;\n        if (added) {\n            parent.content.removeChild(this.hitCanvas._canvas);\n        }\n        else {\n            parent.content.appendChild(this.hitCanvas._canvas);\n        }\n    };\n    Layer.prototype.setSize = function (_a) {\n        var width = _a.width, height = _a.height;\n        _super.prototype.setSize.call(this, { width: width, height: height });\n        this.hitCanvas.setSize(width, height);\n        return this;\n    };\n    return Layer;\n}(BaseLayer_1.BaseLayer));\nexports.Layer = Layer;\nLayer.prototype.nodeType = 'Layer';\nGlobal_1._registerNode(Layer);\nFactory_1.Factory.addGetterSetter(Layer, 'hitGraphEnabled', true, Validators_1.getBooleanValidator());\nUtil_1.Collection.mapMethods(Layer);\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$konva$lib$Factory","~$module$node_modules$konva$lib$Validators","~$shadow.js","~$module$node_modules$konva$lib$Global","~$module$node_modules$konva$lib$Shape","~$module$node_modules$konva$lib$Container","~$module$node_modules$konva$lib$Canvas","~$module$node_modules$konva$lib$Util","~$module$node_modules$konva$lib$BaseLayer"]],"~:properties",["^5",["drawScene","width","_setCanvasSize","prototype","height","_getIntersection","shape","hitCanvas","toggleHitCanvas","x","_validateAdd","__esModule","getIntersection","drawHit","pixelRatio","Layer","nodeType","value","enableHitGraph","y","__proto__","setSize","clear","antialiased","disableHitGraph","node","constructor"]],"~:compiled-at",1606343224193,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$konva$lib$Layer.js\",\n\"lineCount\":6,\n\"mappings\":\"AAAAA,cAAA,CAAe,EAAf,CAAA,CAAqB,QAAQ,CAACC,CAAD,CAAQC,CAAR,CAAgBC,CAAhB,CAAuBC,CAAvB,CAAgC,CAE7D,IAAIC,EAAa,IAAbA,EAAqB,IAAAA,UAArBA,EAAyC,QAAS,EAAG,CACrD,IAAIC,EAAgBA,QAAS,CAACC,CAAD,CAAIC,CAAJ,CAAO,CAChCF,CAAA,CAAgBG,MAAAC,eAAhB,EACK,CAAEC,UAAW,EAAb,CADL,UACkCC,MADlC,EAC2C,QAAS,CAACL,CAAD,CAAIC,CAAJ,CAAO,CAAED,CAAAI,UAAA,CAAcH,CAAhB,CAD3D,EAEI,QAAS,CAACD,CAAD,CAAIC,CAAJ,CAAO,CAAE,IAAKK,IAAIA,CAAT,GAAcL,EAAd,CAAqBA,CAAAM,eAAA,CAAiBD,CAAjB,CAAJ,GAAyBN,CAAA,CAAEM,CAAF,CAAzB,CAAgCL,CAAA,CAAEK,CAAF,CAAhC,CAAnB,CACpB,OAAOP,EAAA,CAAcC,CAAd,CAAiBC,CAAjB,CAJyB,CAMpC,OAAO,SAAS,CAACD,CAAD,CAAIC,CAAJ,CAAO,CAEnBO,QAASA,EAAE,EAAG,CAAE,IAAAC,YAAA,CAAmBT,CAArB,CADdD,CAAA,CAAcC,CAAd,CAAiBC,CAAjB,CAEAD,EAAAU,UAAA,CAAoB,IAAN,GAAAT,CAAA,CAAaC,MAAAS,OAAA,CAAcV,CAAd,CAAb,EAAiCO,CAAAE,UAAA,CAAeT,CAAAS,UAAf,CAA4B,IAAIF,CAAjE,CAHK,CAP8B,CAAb,EAa5CN,OAAAU,eAAA,CAAsBf,CAAtB,CAA+B,YAA/B,CAA6C,CAAEgB,MAAO,CAAA,CAAT,CAA7C,CACA,KAAIC,EAASnB,CAAA,CAAQ,EAAR,CAAb,CACIoB,EAAcpB,CAAA,CAAQ,EAAR,CACdqB,EAAAA,CAAYrB,CAAA,CAAQ,EAAR,CAChB,KAAIsB,EAActB,CAAA,CAAQ,EAAR,CAAlB,CACIuB,EAAWvB,CAAA,CAAQ,EAAR,CADf,CAEIwB,EAAUxB,CAAA,CAAQ,EAAR,CACVyB,EAAAA;AAAezB,CAAA,CAAQ,EAAR,CACf0B,EAAAA,CAAW1B,CAAA,CAAQ,EAAR,CAvB8C,KAwBF2B,EAAuB,CAC9E,CAAEC,EAAG,CAAL,CAAQC,EAAG,CAAX,CAD8E,CAE9E,CAAED,EAAI,EAAN,CAASC,EAAI,EAAb,CAF8E,CAG9E,CAAED,EAAG,CAAL,CAAQC,EAAI,EAAZ,CAH8E,CAI9E,CAAED,EAAG,CAAL,CAAQC,EAAG,CAAX,CAJ8E,CAK9E,CAAED,EAAI,EAAN,CAASC,EAAG,CAAZ,CAL8E,CAxBrB,CA8B1DC,EAA2BH,CAAAI,OA9B+B,CA+BzDC,EAAS,QAAS,CAACC,CAAD,CAAS,CAE3BD,QAASA,EAAK,EAAG,CACb,IAAIE,EAAmB,IAAnBA,GAAQD,CAARC,EAA2BD,CAAAE,MAAA,CAAa,IAAb,CAAmBC,SAAnB,CAA3BF,EAA4D,IAChEA,EAAAG,UAAA,CAAkB,IAAId,CAAAe,UAAJ,CAAuB,CACrCC,WAAY,CADyB,CAAvB,CAGlB,OAAOL,EALM,CADjB/B,CAAA,CAAU6B,CAAV,CAAiBC,CAAjB,CAQAD,EAAAjB,UAAAyB,eAAA,CAAiCC,QAAS,CAACC,CAAD,CAAQC,CAAR,CAAgB,CACtD,IAAAC,OAAAC,QAAA,CAAoBH,CAApB,CAA2BC,CAA3B,CACA,KAAAN,UAAAQ,QAAA,CAAuBH,CAAvB,CAA8BC,CAA9B,CACA,KAAAG,aAAA,EAHsD,CAK1Dd,EAAAjB,UAAAgC,aAAA,CAA+BC,QAAS,CAACC,CAAD,CAAQ,CACxCC,CAAAA,CAAOD,CAAAE,QAAA,EACE,QAAb,GAAID,CAAJ,EAAiC,OAAjC,GAAwBA,CAAxB,EACI/B,CAAAiC,KAAAC,MAAA,CAAkB,gDAAlB,CAHwC,CAMhDrB,EAAAjB,UAAAuC,gBAAA;AAAkCC,QAAS,CAACC,CAAD,CAAMC,CAAN,CAAgB,CAAA,IAC9CC,CAD8C,CACvBC,CAChC,IAAI,CAAC,IAAAC,gBAAA,EAAL,EAA+B,CAAC,IAAAC,UAAA,EAAhC,CACI,MAAO,KAEX,KAAIC,EAAuB,CAE3B,KADIC,CACJ,CADqB,CAAA,CACrB,CAAA,CAAA,CAAa,CACT,IAAKL,CAAL,CAAS,CAAT,CAAYA,CAAZ,CAAgB5B,CAAhB,CAA0C4B,CAAA,EAA1C,CAA+C,CAC3C,IAAAM,EAAqBrC,CAAA,CAAqB+B,CAArB,CACrBO,EAAA,CAAM,IAAAC,iBAAA,CAAsB,CACxBtC,EAAG4B,CAAA5B,EAAHA,CAAWoC,CAAApC,EAAXA,CAAkCkC,CADV,CAExBjC,EAAG2B,CAAA3B,EAAHA,CAAWmC,CAAAnC,EAAXA,CAAkCiC,CAFV,CAAtB,CAKN,KADAH,CACA,CADQM,CAAAN,MACR,GAAaF,CAAb,CACI,MAAOE,EAAAQ,aAAA,CAAmBV,CAAnB,CAA6B,CAAA,CAA7B,CAEN,IAAIE,CAAJ,CACD,MAAOA,EAEXI,EAAA,CAAiB,CAAC,CAACE,CAAAG,YACnB,IAAI,CAACH,CAAAG,YAAL,CACI,KAfuC,CAkB/C,GAAIL,CAAJ,CACID,CAAA,EAAwB,CAD5B,KAII,OAAO,KAvBF,CAP0C,CAkC3D9B,EAAAjB,UAAAmD,iBAAA,CAAmCG,QAAS,CAACb,CAAD,CAAM,CAC9C,IAAIc,EAAQ,IAAAjC,UAAAE,WACR5B,EAAAA,CAAI,IAAA0B,UAAAkC,QAAAC,aAAA,CAAoCC,IAAAC,MAAA,CAAWlB,CAAA5B,EAAX,CAAmB0C,CAAnB,CAApC,CAA+DG,IAAAC,MAAA,CAAWlB,CAAA3B,EAAX,CAAmByC,CAAnB,CAA/D,CAA0F,CAA1F,CAA6F,CAA7F,CAAAK,KAAsGC,EAAAA,CAAKjE,CAAA,CAAE,CAAF,CACnH,OAAW,IAAX,GAAIiE,CAAJ,EACIC,CAEA,CAFW1D,CAAAiC,KAAA0B,UAAA,CAAsBnE,CAAA,CAAE,CAAF,CAAtB;AAA4BA,CAAA,CAAE,CAAF,CAA5B,CAAkCA,CAAA,CAAE,CAAF,CAAlC,CAEX,CAAA,CADAgD,CACA,CADQnC,CAAAuD,OAAA,CAlETC,GAkES,CAAsBH,CAAtB,CACR,EACW,CACHlB,MAAOA,CADJ,CADX,CAKO,CACHS,YAAa,CAAA,CADV,CARX,EAYc,CAAT,CAAIQ,CAAJ,CACM,CACHR,YAAa,CAAA,CADV,CADN,CAKE,EApBuC,CAsBlDpC,EAAAjB,UAAAkE,UAAA,CAA4BC,QAAS,CAACC,CAAD,CAAMC,CAAN,CAAW,CAAA,IACxCC,EAAQ,IAAAC,SAAA,EAAiB1C,EAAAA,CAASuC,CAATvC,EAAiByC,CAAjBzC,EAA0ByC,CAAAE,UAAA,EACvD,KAAAC,MAAA,CArFsBC,YAqFtB,CAAwB,CACpBC,KAAM,IADc,CAAxB,CAGI,KAAAC,gBAAA,EAAJ,EACI/C,CAAAgD,WAAA,EAAAC,MAAA,EAEJzE,EAAA0E,UAAA/E,UAAAkE,UAAAc,KAAA,CAA+C,IAA/C,CAAqDnD,CAArD,CAA6DwC,CAA7D,CACA,KAAAI,MAAA,CA5F2CQ,MA4F3C,CAAiB,CACbN,KAAM,IADO,CAAjB,CAGA,OAAO,KAZqC,CAchD1D,EAAAjB,UAAAkF,QAAA,CAA0BC,QAAS,CAACf,CAAD,CAAMC,CAAN,CAAW,CAAA,IACtCC,EAAQ,IAAAC,SAAA,EAAiB1C,EAAAA,CAASuC,CAATvC,EAAiByC,CAAjBzC,EAA0ByC,CAAAhD,UACnDgD,EAAJ,EAAaA,CAAAM,gBAAA,EAAb,EACIN,CAAAc,aAAA,EAAAP,WAAA,EAAAC,MAAA,EAKJzE,EAAA0E,UAAA/E,UAAAkF,QAAAF,KAAA,CAA6C,IAA7C;AAAmDnD,CAAnD,CAA2DwC,CAA3D,CACA,OAAO,KATmC,CAW9CpD,EAAAjB,UAAA8E,MAAA,CAAwBO,QAAS,CAACC,CAAD,CAAS,CACtC/E,CAAAgF,UAAAvF,UAAA8E,MAAAE,KAAA,CAA2C,IAA3C,CAAiDM,CAAjD,CACA,KAAAF,aAAA,EAAAP,WAAA,EAAAC,MAAA,CAEWQ,CAFX,CAGA,OAAO,KAL+B,CAO1CrE,EAAAjB,UAAAwF,eAAA,CAAiCC,QAAS,EAAG,CACzC,IAAA5C,gBAAA,CAAqB,CAAA,CAArB,CACA,OAAO,KAFkC,CAI7C5B,EAAAjB,UAAA0F,gBAAA,CAAkCC,QAAS,EAAG,CAC1C,IAAA9C,gBAAA,CAAqB,CAAA,CAArB,CACA,OAAO,KAFmC,CAI9C5B,EAAAjB,UAAA4F,gBAAA,CAAkCC,QAAS,EAAG,CAC1C,GAAK,IAAAC,OAAL,CAAA,CAGA,IAAIA,EAAS,IAAAA,OACC,KAAAxE,UAAAyE,QAAAC,WACd,CACIF,CAAAG,QAAAC,YAAA,CAA2B,IAAA5E,UAAAyE,QAA3B,CADJ,CAIID,CAAAG,QAAAE,YAAA,CAA2B,IAAA7E,UAAAyE,QAA3B,CATJ,CAD0C,CAa9C9E,EAAAjB,UAAA8B,QAAA;AAA0BsE,QAAS,CAACC,CAAD,CAAK,CAAA,IAChC1E,EAAQ0E,CAAA1E,MAAUC,EAAAA,CAASyE,CAAAzE,OAC/BV,EAAAlB,UAAA8B,QAAAkD,KAAA,CAA8B,IAA9B,CAAoC,CAAErD,MAAOA,CAAT,CAAgBC,OAAQA,CAAxB,CAApC,CACA,KAAAN,UAAAQ,QAAA,CAAuBH,CAAvB,CAA8BC,CAA9B,CACA,OAAO,KAJ6B,CAMxC,OAAOX,EAvIoB,CAAlB,CAwIXV,CAAAgF,UAxIW,CAyIbpG,EAAA8B,MAAA,CAAgBA,CAChBA,EAAAjB,UAAAsG,SAAA,CAA2B,OAC3B3F,EAAA4F,cAAA,CAAuBtF,CAAvB,CACAX,EAAAkG,QAAAC,gBAAA,CAAkCxF,CAAlC,CAAyC,iBAAzC,CAA4D,CAAA,CAA5D,CAAkEP,CAAAgG,oBAAA,EAAlE,CACAtG,EAAAuG,WAAAC,WAAA,CAA6B3F,CAA7B,CA5K6D;\",\n\"sources\":[\"node_modules/konva/lib/Layer.js\"],\n\"sourcesContent\":[\"shadow$provide[34] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nvar __extends = (this && this.__extends) || (function () {\\n    var extendStatics = function (d, b) {\\n        extendStatics = Object.setPrototypeOf ||\\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\\n        return extendStatics(d, b);\\n    };\\n    return function (d, b) {\\n        extendStatics(d, b);\\n        function __() { this.constructor = d; }\\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\\n    };\\n})();\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nvar Util_1 = require(\\\"./Util\\\");\\nvar Container_1 = require(\\\"./Container\\\");\\nvar Factory_1 = require(\\\"./Factory\\\");\\nvar BaseLayer_1 = require(\\\"./BaseLayer\\\");\\nvar Canvas_1 = require(\\\"./Canvas\\\");\\nvar Shape_1 = require(\\\"./Shape\\\");\\nvar Validators_1 = require(\\\"./Validators\\\");\\nvar Global_1 = require(\\\"./Global\\\");\\nvar HASH = '#', BEFORE_DRAW = 'beforeDraw', DRAW = 'draw', INTERSECTION_OFFSETS = [\\n    { x: 0, y: 0 },\\n    { x: -1, y: -1 },\\n    { x: 1, y: -1 },\\n    { x: 1, y: 1 },\\n    { x: -1, y: 1 }\\n], INTERSECTION_OFFSETS_LEN = INTERSECTION_OFFSETS.length;\\nvar Layer = (function (_super) {\\n    __extends(Layer, _super);\\n    function Layer() {\\n        var _this = _super !== null && _super.apply(this, arguments) || this;\\n        _this.hitCanvas = new Canvas_1.HitCanvas({\\n            pixelRatio: 1\\n        });\\n        return _this;\\n    }\\n    Layer.prototype._setCanvasSize = function (width, height) {\\n        this.canvas.setSize(width, height);\\n        this.hitCanvas.setSize(width, height);\\n        this._checkSmooth();\\n    };\\n    Layer.prototype._validateAdd = function (child) {\\n        var type = child.getType();\\n        if (type !== 'Group' && type !== 'Shape') {\\n            Util_1.Util.throw('You may only add groups and shapes to a layer.');\\n        }\\n    };\\n    Layer.prototype.getIntersection = function (pos, selector) {\\n        var obj, i, intersectionOffset, shape;\\n        if (!this.hitGraphEnabled() || !this.isVisible()) {\\n            return null;\\n        }\\n        var spiralSearchDistance = 1;\\n        var continueSearch = false;\\n        while (true) {\\n            for (i = 0; i < INTERSECTION_OFFSETS_LEN; i++) {\\n                intersectionOffset = INTERSECTION_OFFSETS[i];\\n                obj = this._getIntersection({\\n                    x: pos.x + intersectionOffset.x * spiralSearchDistance,\\n                    y: pos.y + intersectionOffset.y * spiralSearchDistance\\n                });\\n                shape = obj.shape;\\n                if (shape && selector) {\\n                    return shape.findAncestor(selector, true);\\n                }\\n                else if (shape) {\\n                    return shape;\\n                }\\n                continueSearch = !!obj.antialiased;\\n                if (!obj.antialiased) {\\n                    break;\\n                }\\n            }\\n            if (continueSearch) {\\n                spiralSearchDistance += 1;\\n            }\\n            else {\\n                return null;\\n            }\\n        }\\n    };\\n    Layer.prototype._getIntersection = function (pos) {\\n        var ratio = this.hitCanvas.pixelRatio;\\n        var p = this.hitCanvas.context.getImageData(Math.round(pos.x * ratio), Math.round(pos.y * ratio), 1, 1).data, p3 = p[3], colorKey, shape;\\n        if (p3 === 255) {\\n            colorKey = Util_1.Util._rgbToHex(p[0], p[1], p[2]);\\n            shape = Shape_1.shapes[HASH + colorKey];\\n            if (shape) {\\n                return {\\n                    shape: shape\\n                };\\n            }\\n            return {\\n                antialiased: true\\n            };\\n        }\\n        else if (p3 > 0) {\\n            return {\\n                antialiased: true\\n            };\\n        }\\n        return {};\\n    };\\n    Layer.prototype.drawScene = function (can, top) {\\n        var layer = this.getLayer(), canvas = can || (layer && layer.getCanvas());\\n        this._fire(BEFORE_DRAW, {\\n            node: this\\n        });\\n        if (this.clearBeforeDraw()) {\\n            canvas.getContext().clear();\\n        }\\n        Container_1.Container.prototype.drawScene.call(this, canvas, top);\\n        this._fire(DRAW, {\\n            node: this\\n        });\\n        return this;\\n    };\\n    Layer.prototype.drawHit = function (can, top) {\\n        var layer = this.getLayer(), canvas = can || (layer && layer.hitCanvas);\\n        if (layer && layer.clearBeforeDraw()) {\\n            layer\\n                .getHitCanvas()\\n                .getContext()\\n                .clear();\\n        }\\n        Container_1.Container.prototype.drawHit.call(this, canvas, top);\\n        return this;\\n    };\\n    Layer.prototype.clear = function (bounds) {\\n        BaseLayer_1.BaseLayer.prototype.clear.call(this, bounds);\\n        this.getHitCanvas()\\n            .getContext()\\n            .clear(bounds);\\n        return this;\\n    };\\n    Layer.prototype.enableHitGraph = function () {\\n        this.hitGraphEnabled(true);\\n        return this;\\n    };\\n    Layer.prototype.disableHitGraph = function () {\\n        this.hitGraphEnabled(false);\\n        return this;\\n    };\\n    Layer.prototype.toggleHitCanvas = function () {\\n        if (!this.parent) {\\n            return;\\n        }\\n        var parent = this.parent;\\n        var added = !!this.hitCanvas._canvas.parentNode;\\n        if (added) {\\n            parent.content.removeChild(this.hitCanvas._canvas);\\n        }\\n        else {\\n            parent.content.appendChild(this.hitCanvas._canvas);\\n        }\\n    };\\n    Layer.prototype.setSize = function (_a) {\\n        var width = _a.width, height = _a.height;\\n        _super.prototype.setSize.call(this, { width: width, height: height });\\n        this.hitCanvas.setSize(width, height);\\n        return this;\\n    };\\n    return Layer;\\n}(BaseLayer_1.BaseLayer));\\nexports.Layer = Layer;\\nLayer.prototype.nodeType = 'Layer';\\nGlobal_1._registerNode(Layer);\\nFactory_1.Factory.addGetterSetter(Layer, 'hitGraphEnabled', true, Validators_1.getBooleanValidator());\\nUtil_1.Collection.mapMethods(Layer);\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"__extends\",\"extendStatics\",\"d\",\"b\",\"Object\",\"setPrototypeOf\",\"__proto__\",\"Array\",\"p\",\"hasOwnProperty\",\"__\",\"constructor\",\"prototype\",\"create\",\"defineProperty\",\"value\",\"Util_1\",\"Container_1\",\"Factory_1\",\"BaseLayer_1\",\"Canvas_1\",\"Shape_1\",\"Validators_1\",\"Global_1\",\"INTERSECTION_OFFSETS\",\"x\",\"y\",\"INTERSECTION_OFFSETS_LEN\",\"length\",\"Layer\",\"_super\",\"_this\",\"apply\",\"arguments\",\"hitCanvas\",\"HitCanvas\",\"pixelRatio\",\"_setCanvasSize\",\"Layer.prototype._setCanvasSize\",\"width\",\"height\",\"canvas\",\"setSize\",\"_checkSmooth\",\"_validateAdd\",\"Layer.prototype._validateAdd\",\"child\",\"type\",\"getType\",\"Util\",\"throw\",\"getIntersection\",\"Layer.prototype.getIntersection\",\"pos\",\"selector\",\"i\",\"shape\",\"hitGraphEnabled\",\"isVisible\",\"spiralSearchDistance\",\"continueSearch\",\"intersectionOffset\",\"obj\",\"_getIntersection\",\"findAncestor\",\"antialiased\",\"Layer.prototype._getIntersection\",\"ratio\",\"context\",\"getImageData\",\"Math\",\"round\",\"data\",\"p3\",\"colorKey\",\"_rgbToHex\",\"shapes\",\"HASH\",\"drawScene\",\"Layer.prototype.drawScene\",\"can\",\"top\",\"layer\",\"getLayer\",\"getCanvas\",\"_fire\",\"BEFORE_DRAW\",\"node\",\"clearBeforeDraw\",\"getContext\",\"clear\",\"Container\",\"call\",\"DRAW\",\"drawHit\",\"Layer.prototype.drawHit\",\"getHitCanvas\",\"Layer.prototype.clear\",\"bounds\",\"BaseLayer\",\"enableHitGraph\",\"Layer.prototype.enableHitGraph\",\"disableHitGraph\",\"Layer.prototype.disableHitGraph\",\"toggleHitCanvas\",\"Layer.prototype.toggleHitCanvas\",\"parent\",\"_canvas\",\"parentNode\",\"content\",\"removeChild\",\"appendChild\",\"Layer.prototype.setSize\",\"_a\",\"nodeType\",\"_registerNode\",\"Factory\",\"addGetterSetter\",\"getBooleanValidator\",\"Collection\",\"mapMethods\"]\n}\n"]