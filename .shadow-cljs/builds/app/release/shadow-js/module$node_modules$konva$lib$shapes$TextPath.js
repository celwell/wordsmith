["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/konva/lib/shapes/TextPath.js"],"~:js","shadow$provide[65]=function(n,e,t,k){function w(b){b.fillText(this.partialText,0,0)}function v(b){b.strokeText(this.partialText,0,0)}var x=this&&this.__extends||function(){var b=function(a,c){b=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(a,b){a.__proto__=b}||function(a,b){for(var c in b)b.hasOwnProperty(c)&&(a[c]=b[c])};return b(a,c)};return function(a,c){function d(){this.constructor=a}b(a,c);a.prototype=null===c?Object.create(c):(d.prototype=c.prototype,new d)}}();Object.defineProperty(k,\n\"__esModule\",{value:!0});var q=e(22);n=e(24);var m=e(33),d=e(58),b=e(64);t=e(23);e=e(21);m=function(e){function a(a){var b=e.call(this,a)||this;b.dummyCanvas=q.Util.createCanvasElement();b.dataArray=[];b.dataArray=d.Path.parsePathData(b.attrs.data);b.on(\"dataChange.konva\",function(){this.dataArray=d.Path.parsePathData(this.attrs.data);this._setTextData()});b.on(\"textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva\",b._setTextData);a&&a.getKerning&&(q.Util.warn('getKerning TextPath API is deprecated. Please use \"kerningFunc\" instead.'),\nb.kerningFunc(a.getKerning));b._setTextData();return b}x(a,e);a.prototype._sceneFunc=function(a){a.setAttr(\"font\",this._getContextFont());a.setAttr(\"textBaseline\",this.textBaseline());a.setAttr(\"textAlign\",\"left\");a.save();var b=this.textDecoration(),c=this.fill(),d=this.fontSize(),e=this.glyphInfo;\"underline\"===b&&a.beginPath();for(var h=0;h<e.length;h++){a.save();var m=e[h].p0;a.translate(m.x,m.y);a.rotate(e[h].rotation);this.partialText=e[h].text;a.fillStrokeShape(this);\"underline\"===b&&(0===h&&\na.moveTo(0,d/2+1),a.lineTo(d,d/2+1));a.restore()}\"underline\"===b&&(a.strokeStyle=c,a.lineWidth=d/20,a.stroke());a.restore()};a.prototype._hitFunc=function(a){a.beginPath();var b=this.glyphInfo;if(1<=b.length){var c=b[0].p0;a.moveTo(c.x,c.y)}for(c=0;c<b.length;c++){var d=b[c].p1;a.lineTo(d.x,d.y)}a.setAttr(\"lineWidth\",this.fontSize());a.setAttr(\"strokeStyle\",this.colorKey);a.stroke()};a.prototype.getTextWidth=function(){return this.textWidth};a.prototype.getTextHeight=function(){q.Util.warn(\"text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.\");\nreturn this.textHeight};a.prototype.setText=function(a){return b.Text.prototype.setText.call(this,a)};a.prototype._getContextFont=function(){return b.Text.prototype._getContextFont.call(this)};a.prototype._getTextSize=function(a){var b=this.dummyCanvas.getContext(\"2d\");b.save();b.font=this._getContextFont();a=b.measureText(a);b.restore();return{width:a.width,height:parseInt(this.attrs.fontSize,10)}};a.prototype._setTextData=function(){var a=this,b=this._getTextSize(this.attrs.text),e=this.letterSpacing(),\nh=this.align(),m=this.kerningFunc();this.textWidth=b.width;this.textHeight=b.height;var k=Math.max(this.textWidth+((this.attrs.text||\"\").length-1)*e,0);this.glyphInfo=[];var q=0;for(b=0;b<a.dataArray.length;b++)0<a.dataArray[b].pathLength&&(q+=a.dataArray[b].pathLength);var n=0;\"center\"===h&&(n=Math.max(0,q/2-k/2));\"right\"===h&&(n=Math.max(0,q-k));b=this.text().split(\"\");for(var w=this.text().split(\" \").length-1,v,x,t,O=-1,J=0,aa=function(b){var c=a._getTextSize(b).width+e;\" \"===b&&\"justify\"===h&&\n(c+=(q-k)/w);var m=b=0;for(x=void 0;.01<Math.abs(c-b)/c&&25>m;){m++;for(var p=b;void 0===t;){a:{J=0;for(var n=a.dataArray,r=O+1;r<n.length;r++)if(0<n[r].pathLength){O=r;t=n[r];break a}else\"M\"===n[r].command&&(v={x:n[r].points[0],y:n[r].points[1]});t={}}t&&p+t.pathLength<c&&(p+=t.pathLength,t=void 0)}if(t==={}||void 0===v)break;p=!1;switch(t.command){case \"L\":d.Path.getLineLength(v.x,v.y,t.points[0],t.points[1])>c?x=d.Path.getPointOnLine(c,v.x,v.y,t.points[0],t.points[1],v.x,v.y):t=void 0;break;case \"A\":n=\nt.points[4];r=t.points[5];var z=t.points[4]+r;J=0===J?n+1E-8:c>b?J+Math.PI/180*r/Math.abs(r):J-Math.PI/360*r/Math.abs(r);if(0>r&&J<z||0<=r&&J>z)J=z,p=!0;x=d.Path.getPointOnEllipticalArc(t.points[0],t.points[1],t.points[2],t.points[3],J,t.points[6]);break;case \"C\":J=0===J?c>t.pathLength?1E-8:c/t.pathLength:c>b?J+(c-b)/t.pathLength:J-(b-c)/t.pathLength;1<J&&(J=1,p=!0);x=d.Path.getPointOnCubicBezier(J,t.start.x,t.start.y,t.points[0],t.points[1],t.points[2],t.points[3],t.points[4],t.points[5]);break;\ncase \"Q\":J=0===J?c/t.pathLength:c>b?J+(c-b)/t.pathLength:J-(b-c)/t.pathLength,1<J&&(J=1,p=!0),x=d.Path.getPointOnQuadraticBezier(J,t.start.x,t.start.y,t.points[0],t.points[1],t.points[2],t.points[3])}void 0!==x&&(b=d.Path.getLineLength(v.x,v.y,x.x,x.y));p&&(t=void 0)}},ba=a._getTextSize(\"C\").width+e,ca=0;ca<n/ba;ca++){aa(\"C\");if(void 0===v||void 0===x)break;v=x}for(n=0;n<b.length;n++){aa(b[n]);if(void 0===v||void 0===x)break;ba=d.Path.getLineLength(v.x,v.y,x.x,x.y);ca=0;if(m)try{ca=m(b[n-1],b[n])*\nthis.fontSize()}catch(R){ca=0}v.x+=ca;x.x+=ca;this.textWidth+=ca;ba=d.Path.getPointOnLine(ca+ba/2,v.x,v.y,x.x,x.y);this.glyphInfo.push({transposeX:ba.x,transposeY:ba.y,text:b[n],rotation:Math.atan2(x.y-v.y,x.x-v.x),p0:v,p1:x});v=x}};a.prototype.getSelfRect=function(){var a=[];this.glyphInfo.forEach(function(b){a.push(b.p0.x);a.push(b.p0.y);a.push(b.p1.x);a.push(b.p1.y)});for(var b=a[0],d=a[0],e=a[0],h=a[0],m,k,n=0;n<a.length/2;n++)m=a[2*n],k=a[2*n+1],b=Math.min(b,m),d=Math.max(d,m),e=Math.min(e,k),\nh=Math.max(h,k);m=this.fontSize();return{x:Math.round(b)-m/2,y:Math.round(e)-m/2,width:Math.round(d-b)+m,height:Math.round(h-e)+m}};return a}(m.Shape);k.TextPath=m;m.prototype._fillFunc=w;m.prototype._strokeFunc=v;m.prototype._fillFuncHit=w;m.prototype._strokeFuncHit=v;m.prototype.className=\"TextPath\";m.prototype._attrsAffectingSize=[\"text\",\"fontSize\",\"data\"];e._registerNode(m);n.Factory.addGetterSetter(m,\"data\");n.Factory.addGetterSetter(m,\"fontFamily\",\"Arial\");n.Factory.addGetterSetter(m,\"fontSize\",\n12,t.getNumberValidator());n.Factory.addGetterSetter(m,\"fontStyle\",\"normal\");n.Factory.addGetterSetter(m,\"align\",\"left\");n.Factory.addGetterSetter(m,\"letterSpacing\",0,t.getNumberValidator());n.Factory.addGetterSetter(m,\"textBaseline\",\"middle\");n.Factory.addGetterSetter(m,\"fontVariant\",\"normal\");n.Factory.addGetterSetter(m,\"text\",\"\");n.Factory.addGetterSetter(m,\"textDecoration\",null);n.Factory.addGetterSetter(m,\"kerningFunc\",null);q.Collection.mapMethods(m)}","~:source","shadow$provide[65] = function(global,require,module,exports) {\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Util_1 = require(\"../Util\");\nvar Factory_1 = require(\"../Factory\");\nvar Shape_1 = require(\"../Shape\");\nvar Path_1 = require(\"./Path\");\nvar Text_1 = require(\"./Text\");\nvar Validators_1 = require(\"../Validators\");\nvar Global_1 = require(\"../Global\");\nvar EMPTY_STRING = '', NORMAL = 'normal';\nfunction _fillFunc(context) {\n    context.fillText(this.partialText, 0, 0);\n}\nfunction _strokeFunc(context) {\n    context.strokeText(this.partialText, 0, 0);\n}\nvar TextPath = (function (_super) {\n    __extends(TextPath, _super);\n    function TextPath(config) {\n        var _this = _super.call(this, config) || this;\n        _this.dummyCanvas = Util_1.Util.createCanvasElement();\n        _this.dataArray = [];\n        _this.dataArray = Path_1.Path.parsePathData(_this.attrs.data);\n        _this.on('dataChange.konva', function () {\n            this.dataArray = Path_1.Path.parsePathData(this.attrs.data);\n            this._setTextData();\n        });\n        _this.on('textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva', _this._setTextData);\n        if (config && config['getKerning']) {\n            Util_1.Util.warn('getKerning TextPath API is deprecated. Please use \"kerningFunc\" instead.');\n            _this.kerningFunc(config['getKerning']);\n        }\n        _this._setTextData();\n        return _this;\n    }\n    TextPath.prototype._sceneFunc = function (context) {\n        context.setAttr('font', this._getContextFont());\n        context.setAttr('textBaseline', this.textBaseline());\n        context.setAttr('textAlign', 'left');\n        context.save();\n        var textDecoration = this.textDecoration();\n        var fill = this.fill();\n        var fontSize = this.fontSize();\n        var glyphInfo = this.glyphInfo;\n        if (textDecoration === 'underline') {\n            context.beginPath();\n        }\n        for (var i = 0; i < glyphInfo.length; i++) {\n            context.save();\n            var p0 = glyphInfo[i].p0;\n            context.translate(p0.x, p0.y);\n            context.rotate(glyphInfo[i].rotation);\n            this.partialText = glyphInfo[i].text;\n            context.fillStrokeShape(this);\n            if (textDecoration === 'underline') {\n                if (i === 0) {\n                    context.moveTo(0, fontSize / 2 + 1);\n                }\n                context.lineTo(fontSize, fontSize / 2 + 1);\n            }\n            context.restore();\n        }\n        if (textDecoration === 'underline') {\n            context.strokeStyle = fill;\n            context.lineWidth = fontSize / 20;\n            context.stroke();\n        }\n        context.restore();\n    };\n    TextPath.prototype._hitFunc = function (context) {\n        context.beginPath();\n        var glyphInfo = this.glyphInfo;\n        if (glyphInfo.length >= 1) {\n            var p0 = glyphInfo[0].p0;\n            context.moveTo(p0.x, p0.y);\n        }\n        for (var i = 0; i < glyphInfo.length; i++) {\n            var p1 = glyphInfo[i].p1;\n            context.lineTo(p1.x, p1.y);\n        }\n        context.setAttr('lineWidth', this.fontSize());\n        context.setAttr('strokeStyle', this.colorKey);\n        context.stroke();\n    };\n    TextPath.prototype.getTextWidth = function () {\n        return this.textWidth;\n    };\n    TextPath.prototype.getTextHeight = function () {\n        Util_1.Util.warn('text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.');\n        return this.textHeight;\n    };\n    TextPath.prototype.setText = function (text) {\n        return Text_1.Text.prototype.setText.call(this, text);\n    };\n    TextPath.prototype._getContextFont = function () {\n        return Text_1.Text.prototype._getContextFont.call(this);\n    };\n    TextPath.prototype._getTextSize = function (text) {\n        var dummyCanvas = this.dummyCanvas;\n        var _context = dummyCanvas.getContext('2d');\n        _context.save();\n        _context.font = this._getContextFont();\n        var metrics = _context.measureText(text);\n        _context.restore();\n        return {\n            width: metrics.width,\n            height: parseInt(this.attrs.fontSize, 10)\n        };\n    };\n    TextPath.prototype._setTextData = function () {\n        var that = this;\n        var size = this._getTextSize(this.attrs.text);\n        var letterSpacing = this.letterSpacing();\n        var align = this.align();\n        var kerningFunc = this.kerningFunc();\n        this.textWidth = size.width;\n        this.textHeight = size.height;\n        var textFullWidth = Math.max(this.textWidth + ((this.attrs.text || '').length - 1) * letterSpacing, 0);\n        this.glyphInfo = [];\n        var fullPathWidth = 0;\n        for (var l = 0; l < that.dataArray.length; l++) {\n            if (that.dataArray[l].pathLength > 0) {\n                fullPathWidth += that.dataArray[l].pathLength;\n            }\n        }\n        var offset = 0;\n        if (align === 'center') {\n            offset = Math.max(0, fullPathWidth / 2 - textFullWidth / 2);\n        }\n        if (align === 'right') {\n            offset = Math.max(0, fullPathWidth - textFullWidth);\n        }\n        var charArr = this.text().split('');\n        var spacesNumber = this.text().split(' ').length - 1;\n        var p0, p1, pathCmd;\n        var pIndex = -1;\n        var currentT = 0;\n        var getNextPathSegment = function () {\n            currentT = 0;\n            var pathData = that.dataArray;\n            for (var j = pIndex + 1; j < pathData.length; j++) {\n                if (pathData[j].pathLength > 0) {\n                    pIndex = j;\n                    return pathData[j];\n                }\n                else if (pathData[j].command === 'M') {\n                    p0 = {\n                        x: pathData[j].points[0],\n                        y: pathData[j].points[1]\n                    };\n                }\n            }\n            return {};\n        };\n        var findSegmentToFitCharacter = function (c) {\n            var glyphWidth = that._getTextSize(c).width + letterSpacing;\n            if (c === ' ' && align === 'justify') {\n                glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;\n            }\n            var currLen = 0;\n            var attempts = 0;\n            p1 = undefined;\n            while (Math.abs(glyphWidth - currLen) / glyphWidth > 0.01 &&\n                attempts < 25) {\n                attempts++;\n                var cumulativePathLength = currLen;\n                while (pathCmd === undefined) {\n                    pathCmd = getNextPathSegment();\n                    if (pathCmd &&\n                        cumulativePathLength + pathCmd.pathLength < glyphWidth) {\n                        cumulativePathLength += pathCmd.pathLength;\n                        pathCmd = undefined;\n                    }\n                }\n                if (pathCmd === {} || p0 === undefined) {\n                    return undefined;\n                }\n                var needNewSegment = false;\n                switch (pathCmd.command) {\n                    case 'L':\n                        if (Path_1.Path.getLineLength(p0.x, p0.y, pathCmd.points[0], pathCmd.points[1]) > glyphWidth) {\n                            p1 = Path_1.Path.getPointOnLine(glyphWidth, p0.x, p0.y, pathCmd.points[0], pathCmd.points[1], p0.x, p0.y);\n                        }\n                        else {\n                            pathCmd = undefined;\n                        }\n                        break;\n                    case 'A':\n                        var start = pathCmd.points[4];\n                        var dTheta = pathCmd.points[5];\n                        var end = pathCmd.points[4] + dTheta;\n                        if (currentT === 0) {\n                            currentT = start + 0.00000001;\n                        }\n                        else if (glyphWidth > currLen) {\n                            currentT += ((Math.PI / 180.0) * dTheta) / Math.abs(dTheta);\n                        }\n                        else {\n                            currentT -= ((Math.PI / 360.0) * dTheta) / Math.abs(dTheta);\n                        }\n                        if ((dTheta < 0 && currentT < end) ||\n                            (dTheta >= 0 && currentT > end)) {\n                            currentT = end;\n                            needNewSegment = true;\n                        }\n                        p1 = Path_1.Path.getPointOnEllipticalArc(pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], currentT, pathCmd.points[6]);\n                        break;\n                    case 'C':\n                        if (currentT === 0) {\n                            if (glyphWidth > pathCmd.pathLength) {\n                                currentT = 0.00000001;\n                            }\n                            else {\n                                currentT = glyphWidth / pathCmd.pathLength;\n                            }\n                        }\n                        else if (glyphWidth > currLen) {\n                            currentT += (glyphWidth - currLen) / pathCmd.pathLength;\n                        }\n                        else {\n                            currentT -= (currLen - glyphWidth) / pathCmd.pathLength;\n                        }\n                        if (currentT > 1.0) {\n                            currentT = 1.0;\n                            needNewSegment = true;\n                        }\n                        p1 = Path_1.Path.getPointOnCubicBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], pathCmd.points[4], pathCmd.points[5]);\n                        break;\n                    case 'Q':\n                        if (currentT === 0) {\n                            currentT = glyphWidth / pathCmd.pathLength;\n                        }\n                        else if (glyphWidth > currLen) {\n                            currentT += (glyphWidth - currLen) / pathCmd.pathLength;\n                        }\n                        else {\n                            currentT -= (currLen - glyphWidth) / pathCmd.pathLength;\n                        }\n                        if (currentT > 1.0) {\n                            currentT = 1.0;\n                            needNewSegment = true;\n                        }\n                        p1 = Path_1.Path.getPointOnQuadraticBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3]);\n                        break;\n                }\n                if (p1 !== undefined) {\n                    currLen = Path_1.Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n                }\n                if (needNewSegment) {\n                    needNewSegment = false;\n                    pathCmd = undefined;\n                }\n            }\n        };\n        var testChar = 'C';\n        var glyphWidth = that._getTextSize(testChar).width + letterSpacing;\n        for (var k = 0; k < offset / glyphWidth; k++) {\n            findSegmentToFitCharacter(testChar);\n            if (p0 === undefined || p1 === undefined) {\n                break;\n            }\n            p0 = p1;\n        }\n        for (var i = 0; i < charArr.length; i++) {\n            findSegmentToFitCharacter(charArr[i]);\n            if (p0 === undefined || p1 === undefined) {\n                break;\n            }\n            var width = Path_1.Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n            var kern = 0;\n            if (kerningFunc) {\n                try {\n                    kern = kerningFunc(charArr[i - 1], charArr[i]) * this.fontSize();\n                }\n                catch (e) {\n                    kern = 0;\n                }\n            }\n            p0.x += kern;\n            p1.x += kern;\n            this.textWidth += kern;\n            var midpoint = Path_1.Path.getPointOnLine(kern + width / 2.0, p0.x, p0.y, p1.x, p1.y);\n            var rotation = Math.atan2(p1.y - p0.y, p1.x - p0.x);\n            this.glyphInfo.push({\n                transposeX: midpoint.x,\n                transposeY: midpoint.y,\n                text: charArr[i],\n                rotation: rotation,\n                p0: p0,\n                p1: p1\n            });\n            p0 = p1;\n        }\n    };\n    TextPath.prototype.getSelfRect = function () {\n        var points = [];\n        this.glyphInfo.forEach(function (info) {\n            points.push(info.p0.x);\n            points.push(info.p0.y);\n            points.push(info.p1.x);\n            points.push(info.p1.y);\n        });\n        var minX = points[0];\n        var maxX = points[0];\n        var minY = points[0];\n        var maxY = points[0];\n        var x, y;\n        for (var i = 0; i < points.length / 2; i++) {\n            x = points[i * 2];\n            y = points[i * 2 + 1];\n            minX = Math.min(minX, x);\n            maxX = Math.max(maxX, x);\n            minY = Math.min(minY, y);\n            maxY = Math.max(maxY, y);\n        }\n        var fontSize = this.fontSize();\n        return {\n            x: Math.round(minX) - fontSize / 2,\n            y: Math.round(minY) - fontSize / 2,\n            width: Math.round(maxX - minX) + fontSize,\n            height: Math.round(maxY - minY) + fontSize\n        };\n    };\n    return TextPath;\n}(Shape_1.Shape));\nexports.TextPath = TextPath;\nTextPath.prototype._fillFunc = _fillFunc;\nTextPath.prototype._strokeFunc = _strokeFunc;\nTextPath.prototype._fillFuncHit = _fillFunc;\nTextPath.prototype._strokeFuncHit = _strokeFunc;\nTextPath.prototype.className = 'TextPath';\nTextPath.prototype._attrsAffectingSize = ['text', 'fontSize', 'data'];\nGlobal_1._registerNode(TextPath);\nFactory_1.Factory.addGetterSetter(TextPath, 'data');\nFactory_1.Factory.addGetterSetter(TextPath, 'fontFamily', 'Arial');\nFactory_1.Factory.addGetterSetter(TextPath, 'fontSize', 12, Validators_1.getNumberValidator());\nFactory_1.Factory.addGetterSetter(TextPath, 'fontStyle', NORMAL);\nFactory_1.Factory.addGetterSetter(TextPath, 'align', 'left');\nFactory_1.Factory.addGetterSetter(TextPath, 'letterSpacing', 0, Validators_1.getNumberValidator());\nFactory_1.Factory.addGetterSetter(TextPath, 'textBaseline', 'middle');\nFactory_1.Factory.addGetterSetter(TextPath, 'fontVariant', NORMAL);\nFactory_1.Factory.addGetterSetter(TextPath, 'text', EMPTY_STRING);\nFactory_1.Factory.addGetterSetter(TextPath, 'textDecoration', null);\nFactory_1.Factory.addGetterSetter(TextPath, 'kerningFunc', null);\nUtil_1.Collection.mapMethods(TextPath);\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$konva$lib$Factory","~$module$node_modules$konva$lib$shapes$Path","~$module$node_modules$konva$lib$Validators","~$module$node_modules$konva$lib$shapes$Text","~$shadow.js","~$module$node_modules$konva$lib$Global","~$module$node_modules$konva$lib$Shape","~$module$node_modules$konva$lib$Util"]],"~:properties",["^5",["width","lineWidth","TextPath","_fillFuncHit","prototype","height","_strokeFunc","partialText","setText","getTextWidth","className","glyphInfo","getSelfRect","x","__esModule","textHeight","_getContextFont","_sceneFunc","getTextHeight","p0","value","transposeX","textWidth","text","rotation","font","_hitFunc","dummyCanvas","y","__proto__","_fillFunc","_attrsAffectingSize","p1","_setTextData","strokeStyle","_strokeFuncHit","_getTextSize","transposeY","dataArray","constructor"]],"~:compiled-at",1589761458354,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$konva$lib$shapes$TextPath.js\",\n\"lineCount\":12,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/konva/lib/shapes/TextPath.js\"],\n\"sourcesContent\":[\"shadow$provide[65] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nvar __extends = (this && this.__extends) || (function () {\\n    var extendStatics = function (d, b) {\\n        extendStatics = Object.setPrototypeOf ||\\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\\n        return extendStatics(d, b);\\n    };\\n    return function (d, b) {\\n        extendStatics(d, b);\\n        function __() { this.constructor = d; }\\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\\n    };\\n})();\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nvar Util_1 = require(\\\"../Util\\\");\\nvar Factory_1 = require(\\\"../Factory\\\");\\nvar Shape_1 = require(\\\"../Shape\\\");\\nvar Path_1 = require(\\\"./Path\\\");\\nvar Text_1 = require(\\\"./Text\\\");\\nvar Validators_1 = require(\\\"../Validators\\\");\\nvar Global_1 = require(\\\"../Global\\\");\\nvar EMPTY_STRING = '', NORMAL = 'normal';\\nfunction _fillFunc(context) {\\n    context.fillText(this.partialText, 0, 0);\\n}\\nfunction _strokeFunc(context) {\\n    context.strokeText(this.partialText, 0, 0);\\n}\\nvar TextPath = (function (_super) {\\n    __extends(TextPath, _super);\\n    function TextPath(config) {\\n        var _this = _super.call(this, config) || this;\\n        _this.dummyCanvas = Util_1.Util.createCanvasElement();\\n        _this.dataArray = [];\\n        _this.dataArray = Path_1.Path.parsePathData(_this.attrs.data);\\n        _this.on('dataChange.konva', function () {\\n            this.dataArray = Path_1.Path.parsePathData(this.attrs.data);\\n            this._setTextData();\\n        });\\n        _this.on('textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva', _this._setTextData);\\n        if (config && config['getKerning']) {\\n            Util_1.Util.warn('getKerning TextPath API is deprecated. Please use \\\"kerningFunc\\\" instead.');\\n            _this.kerningFunc(config['getKerning']);\\n        }\\n        _this._setTextData();\\n        return _this;\\n    }\\n    TextPath.prototype._sceneFunc = function (context) {\\n        context.setAttr('font', this._getContextFont());\\n        context.setAttr('textBaseline', this.textBaseline());\\n        context.setAttr('textAlign', 'left');\\n        context.save();\\n        var textDecoration = this.textDecoration();\\n        var fill = this.fill();\\n        var fontSize = this.fontSize();\\n        var glyphInfo = this.glyphInfo;\\n        if (textDecoration === 'underline') {\\n            context.beginPath();\\n        }\\n        for (var i = 0; i < glyphInfo.length; i++) {\\n            context.save();\\n            var p0 = glyphInfo[i].p0;\\n            context.translate(p0.x, p0.y);\\n            context.rotate(glyphInfo[i].rotation);\\n            this.partialText = glyphInfo[i].text;\\n            context.fillStrokeShape(this);\\n            if (textDecoration === 'underline') {\\n                if (i === 0) {\\n                    context.moveTo(0, fontSize / 2 + 1);\\n                }\\n                context.lineTo(fontSize, fontSize / 2 + 1);\\n            }\\n            context.restore();\\n        }\\n        if (textDecoration === 'underline') {\\n            context.strokeStyle = fill;\\n            context.lineWidth = fontSize / 20;\\n            context.stroke();\\n        }\\n        context.restore();\\n    };\\n    TextPath.prototype._hitFunc = function (context) {\\n        context.beginPath();\\n        var glyphInfo = this.glyphInfo;\\n        if (glyphInfo.length >= 1) {\\n            var p0 = glyphInfo[0].p0;\\n            context.moveTo(p0.x, p0.y);\\n        }\\n        for (var i = 0; i < glyphInfo.length; i++) {\\n            var p1 = glyphInfo[i].p1;\\n            context.lineTo(p1.x, p1.y);\\n        }\\n        context.setAttr('lineWidth', this.fontSize());\\n        context.setAttr('strokeStyle', this.colorKey);\\n        context.stroke();\\n    };\\n    TextPath.prototype.getTextWidth = function () {\\n        return this.textWidth;\\n    };\\n    TextPath.prototype.getTextHeight = function () {\\n        Util_1.Util.warn('text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.');\\n        return this.textHeight;\\n    };\\n    TextPath.prototype.setText = function (text) {\\n        return Text_1.Text.prototype.setText.call(this, text);\\n    };\\n    TextPath.prototype._getContextFont = function () {\\n        return Text_1.Text.prototype._getContextFont.call(this);\\n    };\\n    TextPath.prototype._getTextSize = function (text) {\\n        var dummyCanvas = this.dummyCanvas;\\n        var _context = dummyCanvas.getContext('2d');\\n        _context.save();\\n        _context.font = this._getContextFont();\\n        var metrics = _context.measureText(text);\\n        _context.restore();\\n        return {\\n            width: metrics.width,\\n            height: parseInt(this.attrs.fontSize, 10)\\n        };\\n    };\\n    TextPath.prototype._setTextData = function () {\\n        var that = this;\\n        var size = this._getTextSize(this.attrs.text);\\n        var letterSpacing = this.letterSpacing();\\n        var align = this.align();\\n        var kerningFunc = this.kerningFunc();\\n        this.textWidth = size.width;\\n        this.textHeight = size.height;\\n        var textFullWidth = Math.max(this.textWidth + ((this.attrs.text || '').length - 1) * letterSpacing, 0);\\n        this.glyphInfo = [];\\n        var fullPathWidth = 0;\\n        for (var l = 0; l < that.dataArray.length; l++) {\\n            if (that.dataArray[l].pathLength > 0) {\\n                fullPathWidth += that.dataArray[l].pathLength;\\n            }\\n        }\\n        var offset = 0;\\n        if (align === 'center') {\\n            offset = Math.max(0, fullPathWidth / 2 - textFullWidth / 2);\\n        }\\n        if (align === 'right') {\\n            offset = Math.max(0, fullPathWidth - textFullWidth);\\n        }\\n        var charArr = this.text().split('');\\n        var spacesNumber = this.text().split(' ').length - 1;\\n        var p0, p1, pathCmd;\\n        var pIndex = -1;\\n        var currentT = 0;\\n        var getNextPathSegment = function () {\\n            currentT = 0;\\n            var pathData = that.dataArray;\\n            for (var j = pIndex + 1; j < pathData.length; j++) {\\n                if (pathData[j].pathLength > 0) {\\n                    pIndex = j;\\n                    return pathData[j];\\n                }\\n                else if (pathData[j].command === 'M') {\\n                    p0 = {\\n                        x: pathData[j].points[0],\\n                        y: pathData[j].points[1]\\n                    };\\n                }\\n            }\\n            return {};\\n        };\\n        var findSegmentToFitCharacter = function (c) {\\n            var glyphWidth = that._getTextSize(c).width + letterSpacing;\\n            if (c === ' ' && align === 'justify') {\\n                glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;\\n            }\\n            var currLen = 0;\\n            var attempts = 0;\\n            p1 = undefined;\\n            while (Math.abs(glyphWidth - currLen) / glyphWidth > 0.01 &&\\n                attempts < 25) {\\n                attempts++;\\n                var cumulativePathLength = currLen;\\n                while (pathCmd === undefined) {\\n                    pathCmd = getNextPathSegment();\\n                    if (pathCmd &&\\n                        cumulativePathLength + pathCmd.pathLength < glyphWidth) {\\n                        cumulativePathLength += pathCmd.pathLength;\\n                        pathCmd = undefined;\\n                    }\\n                }\\n                if (pathCmd === {} || p0 === undefined) {\\n                    return undefined;\\n                }\\n                var needNewSegment = false;\\n                switch (pathCmd.command) {\\n                    case 'L':\\n                        if (Path_1.Path.getLineLength(p0.x, p0.y, pathCmd.points[0], pathCmd.points[1]) > glyphWidth) {\\n                            p1 = Path_1.Path.getPointOnLine(glyphWidth, p0.x, p0.y, pathCmd.points[0], pathCmd.points[1], p0.x, p0.y);\\n                        }\\n                        else {\\n                            pathCmd = undefined;\\n                        }\\n                        break;\\n                    case 'A':\\n                        var start = pathCmd.points[4];\\n                        var dTheta = pathCmd.points[5];\\n                        var end = pathCmd.points[4] + dTheta;\\n                        if (currentT === 0) {\\n                            currentT = start + 0.00000001;\\n                        }\\n                        else if (glyphWidth > currLen) {\\n                            currentT += ((Math.PI / 180.0) * dTheta) / Math.abs(dTheta);\\n                        }\\n                        else {\\n                            currentT -= ((Math.PI / 360.0) * dTheta) / Math.abs(dTheta);\\n                        }\\n                        if ((dTheta < 0 && currentT < end) ||\\n                            (dTheta >= 0 && currentT > end)) {\\n                            currentT = end;\\n                            needNewSegment = true;\\n                        }\\n                        p1 = Path_1.Path.getPointOnEllipticalArc(pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], currentT, pathCmd.points[6]);\\n                        break;\\n                    case 'C':\\n                        if (currentT === 0) {\\n                            if (glyphWidth > pathCmd.pathLength) {\\n                                currentT = 0.00000001;\\n                            }\\n                            else {\\n                                currentT = glyphWidth / pathCmd.pathLength;\\n                            }\\n                        }\\n                        else if (glyphWidth > currLen) {\\n                            currentT += (glyphWidth - currLen) / pathCmd.pathLength;\\n                        }\\n                        else {\\n                            currentT -= (currLen - glyphWidth) / pathCmd.pathLength;\\n                        }\\n                        if (currentT > 1.0) {\\n                            currentT = 1.0;\\n                            needNewSegment = true;\\n                        }\\n                        p1 = Path_1.Path.getPointOnCubicBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], pathCmd.points[4], pathCmd.points[5]);\\n                        break;\\n                    case 'Q':\\n                        if (currentT === 0) {\\n                            currentT = glyphWidth / pathCmd.pathLength;\\n                        }\\n                        else if (glyphWidth > currLen) {\\n                            currentT += (glyphWidth - currLen) / pathCmd.pathLength;\\n                        }\\n                        else {\\n                            currentT -= (currLen - glyphWidth) / pathCmd.pathLength;\\n                        }\\n                        if (currentT > 1.0) {\\n                            currentT = 1.0;\\n                            needNewSegment = true;\\n                        }\\n                        p1 = Path_1.Path.getPointOnQuadraticBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3]);\\n                        break;\\n                }\\n                if (p1 !== undefined) {\\n                    currLen = Path_1.Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\\n                }\\n                if (needNewSegment) {\\n                    needNewSegment = false;\\n                    pathCmd = undefined;\\n                }\\n            }\\n        };\\n        var testChar = 'C';\\n        var glyphWidth = that._getTextSize(testChar).width + letterSpacing;\\n        for (var k = 0; k < offset / glyphWidth; k++) {\\n            findSegmentToFitCharacter(testChar);\\n            if (p0 === undefined || p1 === undefined) {\\n                break;\\n            }\\n            p0 = p1;\\n        }\\n        for (var i = 0; i < charArr.length; i++) {\\n            findSegmentToFitCharacter(charArr[i]);\\n            if (p0 === undefined || p1 === undefined) {\\n                break;\\n            }\\n            var width = Path_1.Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\\n            var kern = 0;\\n            if (kerningFunc) {\\n                try {\\n                    kern = kerningFunc(charArr[i - 1], charArr[i]) * this.fontSize();\\n                }\\n                catch (e) {\\n                    kern = 0;\\n                }\\n            }\\n            p0.x += kern;\\n            p1.x += kern;\\n            this.textWidth += kern;\\n            var midpoint = Path_1.Path.getPointOnLine(kern + width / 2.0, p0.x, p0.y, p1.x, p1.y);\\n            var rotation = Math.atan2(p1.y - p0.y, p1.x - p0.x);\\n            this.glyphInfo.push({\\n                transposeX: midpoint.x,\\n                transposeY: midpoint.y,\\n                text: charArr[i],\\n                rotation: rotation,\\n                p0: p0,\\n                p1: p1\\n            });\\n            p0 = p1;\\n        }\\n    };\\n    TextPath.prototype.getSelfRect = function () {\\n        var points = [];\\n        this.glyphInfo.forEach(function (info) {\\n            points.push(info.p0.x);\\n            points.push(info.p0.y);\\n            points.push(info.p1.x);\\n            points.push(info.p1.y);\\n        });\\n        var minX = points[0];\\n        var maxX = points[0];\\n        var minY = points[0];\\n        var maxY = points[0];\\n        var x, y;\\n        for (var i = 0; i < points.length / 2; i++) {\\n            x = points[i * 2];\\n            y = points[i * 2 + 1];\\n            minX = Math.min(minX, x);\\n            maxX = Math.max(maxX, x);\\n            minY = Math.min(minY, y);\\n            maxY = Math.max(maxY, y);\\n        }\\n        var fontSize = this.fontSize();\\n        return {\\n            x: Math.round(minX) - fontSize / 2,\\n            y: Math.round(minY) - fontSize / 2,\\n            width: Math.round(maxX - minX) + fontSize,\\n            height: Math.round(maxY - minY) + fontSize\\n        };\\n    };\\n    return TextPath;\\n}(Shape_1.Shape));\\nexports.TextPath = TextPath;\\nTextPath.prototype._fillFunc = _fillFunc;\\nTextPath.prototype._strokeFunc = _strokeFunc;\\nTextPath.prototype._fillFuncHit = _fillFunc;\\nTextPath.prototype._strokeFuncHit = _strokeFunc;\\nTextPath.prototype.className = 'TextPath';\\nTextPath.prototype._attrsAffectingSize = ['text', 'fontSize', 'data'];\\nGlobal_1._registerNode(TextPath);\\nFactory_1.Factory.addGetterSetter(TextPath, 'data');\\nFactory_1.Factory.addGetterSetter(TextPath, 'fontFamily', 'Arial');\\nFactory_1.Factory.addGetterSetter(TextPath, 'fontSize', 12, Validators_1.getNumberValidator());\\nFactory_1.Factory.addGetterSetter(TextPath, 'fontStyle', NORMAL);\\nFactory_1.Factory.addGetterSetter(TextPath, 'align', 'left');\\nFactory_1.Factory.addGetterSetter(TextPath, 'letterSpacing', 0, Validators_1.getNumberValidator());\\nFactory_1.Factory.addGetterSetter(TextPath, 'textBaseline', 'middle');\\nFactory_1.Factory.addGetterSetter(TextPath, 'fontVariant', NORMAL);\\nFactory_1.Factory.addGetterSetter(TextPath, 'text', EMPTY_STRING);\\nFactory_1.Factory.addGetterSetter(TextPath, 'textDecoration', null);\\nFactory_1.Factory.addGetterSetter(TextPath, 'kerningFunc', null);\\nUtil_1.Collection.mapMethods(TextPath);\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_fillFunc\",\"context\",\"fillText\",\"partialText\",\"_strokeFunc\",\"strokeText\",\"__extends\",\"extendStatics\",\"d\",\"b\",\"Object\",\"setPrototypeOf\",\"__proto__\",\"Array\",\"p\",\"hasOwnProperty\",\"__\",\"constructor\",\"prototype\",\"create\",\"defineProperty\",\"value\",\"Util_1\",\"Factory_1\",\"Shape_1\",\"Path_1\",\"Text_1\",\"Validators_1\",\"Global_1\",\"TextPath\",\"_super\",\"config\",\"_this\",\"call\",\"dummyCanvas\",\"Util\",\"createCanvasElement\",\"dataArray\",\"Path\",\"parsePathData\",\"attrs\",\"data\",\"on\",\"_setTextData\",\"warn\",\"kerningFunc\",\"_sceneFunc\",\"TextPath.prototype._sceneFunc\",\"setAttr\",\"_getContextFont\",\"textBaseline\",\"save\",\"textDecoration\",\"fill\",\"fontSize\",\"glyphInfo\",\"beginPath\",\"i\",\"length\",\"p0\",\"translate\",\"x\",\"y\",\"rotate\",\"rotation\",\"text\",\"fillStrokeShape\",\"moveTo\",\"lineTo\",\"restore\",\"strokeStyle\",\"lineWidth\",\"stroke\",\"_hitFunc\",\"TextPath.prototype._hitFunc\",\"p1\",\"colorKey\",\"getTextWidth\",\"TextPath.prototype.getTextWidth\",\"textWidth\",\"getTextHeight\",\"TextPath.prototype.getTextHeight\",\"textHeight\",\"setText\",\"TextPath.prototype.setText\",\"Text\",\"TextPath.prototype._getContextFont\",\"_getTextSize\",\"TextPath.prototype._getTextSize\",\"_context\",\"getContext\",\"font\",\"metrics\",\"measureText\",\"width\",\"height\",\"parseInt\",\"TextPath.prototype._setTextData\",\"that\",\"size\",\"letterSpacing\",\"align\",\"textFullWidth\",\"Math\",\"max\",\"fullPathWidth\",\"l\",\"pathLength\",\"offset\",\"charArr\",\"split\",\"spacesNumber\",\"pathCmd\",\"pIndex\",\"currentT\",\"findSegmentToFitCharacter\",\"c\",\"glyphWidth\",\"attempts\",\"currLen\",\"undefined\",\"abs\",\"cumulativePathLength\",\"pathData\",\"j\",\"command\",\"points\",\"needNewSegment\",\"getLineLength\",\"getPointOnLine\",\"start\",\"dTheta\",\"end\",\"PI\",\"getPointOnEllipticalArc\",\"getPointOnCubicBezier\",\"getPointOnQuadraticBezier\",\"testChar\",\"k\",\"kern\",\"e\",\"midpoint\",\"push\",\"transposeX\",\"transposeY\",\"atan2\",\"getSelfRect\",\"TextPath.prototype.getSelfRect\",\"forEach\",\"info\",\"minX\",\"maxX\",\"minY\",\"maxY\",\"min\",\"round\",\"Shape\",\"_fillFuncHit\",\"_strokeFuncHit\",\"className\",\"_attrsAffectingSize\",\"_registerNode\",\"Factory\",\"addGetterSetter\",\"getNumberValidator\",\"NORMAL\",\"EMPTY_STRING\",\"Collection\",\"mapMethods\"]\n}\n"]